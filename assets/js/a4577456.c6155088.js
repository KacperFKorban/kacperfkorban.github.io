"use strict";(self.webpackChunkkacperfkorban_github_io=self.webpackChunkkacperfkorban_github_io||[]).push([[189],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5275:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return c},toc:function(){return u},default:function(){return m}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={slug:"Data Modeling in Scala 3, but I only use types",title:"Data Modeling in Scala 3, but I only use types",authors:"k\u03c0",tags:["scala","scala 3"]},s="Data Modeling in Scala 3, but I only use types",p={permalink:"/blog/Data Modeling in Scala 3, but I only use types",editUrl:"https://github.com/KacperFKorban/kacperfkorban.github.io/blog/2022-06-06-Data-Modeling-in-Scala-3-but-I-only-use-types.md",source:"@site/blog/2022-06-06-Data-Modeling-in-Scala-3-but-I-only-use-types.md",title:"Data Modeling in Scala 3, but I only use types",description:"That\u2019s the whole idea.",date:"2022-06-06T00:00:00.000Z",formattedDate:"June 6, 2022",tags:[{label:"scala",permalink:"/blog/tags/scala"},{label:"scala 3",permalink:"/blog/tags/scala-3"}],readingTime:7.46,truncated:!1,authors:[{name:"Kacper Korban",url:"https://github.com/KacperFKorban",imageURL:"https://avatars.githubusercontent.com/u/39772805?v=4",key:"k\u03c0"}],nextItem:{title:"Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study",permalink:"/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study"}},c={authorsImageUrls:[void 0]},u=[{value:"Recruitment system",id:"recruitment-system",children:[],level:2},{value:"Making it spicier",id:"making-it-spicier",children:[{value:"Experience level",id:"experience-level",children:[],level:3},{value:"Experience",id:"experience",children:[],level:3},{value:"Candidate",id:"candidate",children:[],level:3}],level:2},{value:"Final form",id:"final-form",children:[],level:2},{value:"C&#39;mon, Do Something",id:"cmon-do-something",children:[],level:2}],d={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"That\u2019s the whole idea."),(0,r.kt)("p",null,"We want to model data in Scala, but instead of using instances of classes at the term level, we want to use their type-constructors at the type level."),(0,r.kt)("h2",{id:"recruitment-system"},"Recruitment system"),(0,r.kt)("p",null,"Let\u2019s pick an example to help us visualize the whole process better, because just like a wise person once said \u201cA picture is worth a thousand words\u201d."),(0,r.kt)("p",null,"We will represent candidate profiles in a recruitment process for software engineering companies. Let\u2019s start with the term model code and I\u2019ll walk you through it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Candidate(\n  name: String,\n  experience: List[Experience],\n  otherQualities: List[String]\n)\n\ncase class Experience(\n  duration: Int,\n  expLevel: ExpLevel,\n  company: String,\n  technologies: List[String]\n)\n\nenum ExpLevel:\n  case Junior\n  case Regular\n  case Senior\n  case CEO\nexport ExpLevel.*\n")),(0,r.kt)("p",null,"We can represent candidates by providing their:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"name \u2013 just a String"),(0,r.kt)("li",{parentName:"ul"},"experience history \u2013 list of Experience entries"),(0,r.kt)("li",{parentName:"ul"},"other qualities \u2013 list of string")),(0,r.kt)("p",null,"And experience entry is represented by:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"duration \u2013 number of months at the job"),(0,r.kt)("li",{parentName:"ul"},"experience level \u2013 enum value representing experience levels in IT"),(0,r.kt)("li",{parentName:"ul"},"company name \u2013 a String"),(0,r.kt)("li",{parentName:"ul"},"technologies \u2013 list of technologies used")),(0,r.kt)("p",null,"So if we were to create a very simplified profile using our model, it will look like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val candidate = Candidate(\n  "John Paul",\n  Experience(\n    29,\n    Junior,\n    "VirtusLab",\n   "Scala" :: Nil\n  ) :: Nil,\n  "Motivated" :: Nil\n)\n')),(0,r.kt)("p",null,"Cool, nothing new so far."),(0,r.kt)("h2",{id:"making-it-spicier"},"Making it spicier"),(0,r.kt)("p",null,"That was some basic Scala. Now what we want to do: is to be able to have all this information on the type level."),(0,r.kt)("p",null,"You might be asking: We already declared a model in the previous section. Can\u2019t we just use that one?\nAs expected, the answer is: No. That\u2019s because Scala distinguishes terms from types. The previous model worked on the term level, and we want to do it on the type level. So, we will have to tweak it a bit."),(0,r.kt)("p",null,"To make our intentions 100% clear, we want to be able to declare a type like the following (or at least similar)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'type candidate = Candidate[\n  "John Paul",\n  Experience[\n    29,\n    Junior,\n    "VirtusLab",\n    "Scala" :: Nil\n  ] :: Nil,\n  "Motivated" :: Nil\n]\n')),(0,r.kt)("p",null,"Let\u2019s start our work with the most basic class and work our way up the dependency graph."),(0,r.kt)("h3",{id:"experience-level"},"Experience level"),(0,r.kt)("p",null,"First, let\u2019s look at ",(0,r.kt)("strong",{parentName:"p"},"ExpLevel"),". We declared it before as"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"enum ExpLevel:\n  case Junior\n  case Regular\n  case Senior\n  case CEO\nexport ExpLevel.*\n")),(0,r.kt)("p",null,"When we think about it, its type constructors carry the same amount of information as its data constructors, so we could leave it as it is.\nThere is a small problem with the current declaration though. When we want to access the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"Junior")," and use it as e.g. a type parameter for ",(0,r.kt)("inlineCode",{parentName:"p"},"List"),", we cannot just say ",(0,r.kt)("inlineCode",{parentName:"p"},"List[Junior]"),". That\u2019s because there is no such type constructor as ",(0,r.kt)("inlineCode",{parentName:"p"},"Junior"),". Instead, we will have to type ",(0,r.kt)("inlineCode",{parentName:"p"},"List[Junior.type]"),". This can be quite annoying, specifically when it\u2019s a part of the interface exposed to the user.\nIs there a way to fix it then? Yes, and it\u2019s actually quite simple. Just like by writing in Python I can force myself into a crippling depression, you can force Scala to generate classes for all our cases by just adding parentheses after the constructors. Then, those won\u2019t just be values, but classes with empty constructors."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"enum ExpLevel:\n  case Junior()\n  case Regular()\n  case Senior()\n  case CEO()\nexport ExpLevel.*\n")),(0,r.kt)("p",null,"Nice, on to the next one."),(0,r.kt)("h3",{id:"experience"},"Experience"),(0,r.kt)("p",null,"Now that we fixed the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExpLevel")," data type, let\u2019s move on to Experience. In the term model, it looked like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Experience(\n  duration: Int,\n  expLevel: ExpLevel,\n  company: String,\n  technologies: List[String]\n)\n")),(0,r.kt)("p",null,"We want all of those term parameters to become type parameters, so let\u2019s try just adding them.\nThe strategy will be, for every term parameter we will:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"create a type parameter with the same name"),(0,r.kt)("li",{parentName:"ol"},"add a type constraint for it using <: operator")),(0,r.kt)("p",null,"It is important that we use <: here and not :. That is because, when used on types, the first one is semantically equivalent to \u201cis subtype of\u201d and the latter means \u201chas implicit instance of\u201d.\nLet\u2019s take a look at the result of our transformation then."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Experience[\n  duration <: Int,\n  expLevel <: ExpLevel,\n  company <: String,\n  technologies <: List[String]\n]()\n")),(0,r.kt)("p",null,"At first glance, it looks ok and it looks very similar to the term model. We have an entry for every parameter and the constraints are the same as before. But does it work? Well, no. If I were to play the role of a build tool, I would say that we have one warning and one error."),(0,r.kt)("p",null,"Let\u2019s start with the warning. Take a look at this class and think, what does the ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," keyword give us here. Well, it gives us the ",(0,r.kt)("inlineCode",{parentName:"p"},"apply")," function to our empty constructor, ",(0,r.kt)("inlineCode",{parentName:"p"},"getters")," to our non-existent fields, the ",(0,r.kt)("inlineCode",{parentName:"p"},"unapply")," function for a class we will never construct, and some other extremely useful methods.\nDo you get the point? The ",(0,r.kt)("inlineCode",{parentName:"p"},"case")," keyword here is just as useful as a cats-effect expert at Ziverge."),(0,r.kt)("p",null,"Cool. On to the error now. This one might not be as easy to spot. To make it easier, let\u2019s look at how List is implemented. Skipping a lot of details, we have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed abstract class List[+A]\nfinal case class :: [+A](head: A, next: List[A]) extends List[A]\ncase object Nil extends List[Nothing]\n")),(0,r.kt)("p",null,"We have a supertype ",(0,r.kt)("inlineCode",{parentName:"p"},"List")," and two type constructors ",(0,r.kt)("inlineCode",{parentName:"p"},"::")," (cons) and ",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),".\n",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),", carries no information since it just symbolizes an empty list. No problem here.\nBut, when we take a look at ",(0,r.kt)("inlineCode",{parentName:"p"},"::"),", it only has one type parameter. This would mean that it will only be able to carry the definition of one ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"Let\u2019s create our own data structure then. To make it easier, it should only contain ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"s."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait StrList\nclass Nl extends StrList\nclass :|:[head <: String, tail <: StrList] extends StrList\n")),(0,r.kt)("p",null,"Voila. We just take a look at the definition of List and move every term parameter to type-level, like before."),(0,r.kt)("p",null,"If we put all the parts together, we get."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class Experience[\n  duration <: Int,\n  expLevel <: ExpLevel,\n  company <: String,\n  technologies <: StrList\n]\n")),(0,r.kt)("h3",{id:"candidate"},"Candidate"),(0,r.kt)("p",null,"Let\u2019s take a look at our last class \u2013 ",(0,r.kt)("inlineCode",{parentName:"p"},"Candidate"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class Candidate(\n  name: String,\n  experience: List[Experience],\n  otherQualities: List[String]\n)\n")),(0,r.kt)("p",null,"Right off the bat, we can spot similar problems as with ",(0,r.kt)("inlineCode",{parentName:"p"},"Experience")," \u2013 Lists. Fortunately, we already have a structure for type-level lists of Strings from before. This means that we just need lists of ",(0,r.kt)("inlineCode",{parentName:"p"},"Experience"),"s. We can declare it in a similar way as with lists of strings, right? Let\u2019s try."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Experiences\nclass Empty extends Experiences\nclass :+:[head <: ???, tail <: Experiences] extends Experiences\n")),(0,r.kt)("p",null,"Ok. This looks exactly like the ",(0,r.kt)("inlineCode",{parentName:"p"},"StrList")," with some minor name changes. Why is there a question mark instead of the constraint of head? That\u2019s because we cannot use ",(0,r.kt)("inlineCode",{parentName:"p"},"Experience")," there. ",(0,r.kt)("inlineCode",{parentName:"p"},"Experience")," is a type constructor that takes a non-empty parameter list. We would have to specify it on the spot."),(0,r.kt)("p",null,"Is there some trick we can use here? Or is Scala\u2019s type system not expressive enough?\nOf course, there is a workaround. It is also quite a common pattern. It\u2019s every functional programmer\u2019s biggest nightmare and every object-oriented programmer\u2019s wet dream: ",(0,r.kt)("inlineCode",{parentName:"p"},"Inheritance"),"."),(0,r.kt)("p",null,"If we add a supertype to our ",(0,r.kt)("inlineCode",{parentName:"p"},"Experience")," class, we can use it in every place where we would usually use a type and treat ",(0,r.kt)("inlineCode",{parentName:"p"},"Experience")," as the implementation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"sealed trait Exp\nclass Experience[\n  ...\n] extends Exp\n")),(0,r.kt)("p",null,"Is this solution pretty? No.\nBut as the tapeworm said: There was no other way."),(0,r.kt)("p",null,"Now that we have fixed this issue, there is nothing interesting anymore with transforming the ",(0,r.kt)("inlineCode",{parentName:"p"},"Candidate")," class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"class Candidate[\n  name <: String,\n  experience <: Experiences,\n  otherQualities <: StrList\n]\n")),(0,r.kt)("h2",{id:"final-form"},"Final form"),(0,r.kt)("p",null,"After all that work we can finally write our correct example instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'type mystery = Candidate[\n  "John Paul",\n  Experience[\n    29,\n    Junior,\n    "VirtusLab",\n    "Scala" :|: Nl\n  ] :+: Empty,\n  "Motivated" :|: Nl\n]\n')),(0,r.kt)("p",null,"And it compiles, which means that it works!"),(0,r.kt)("h2",{id:"cmon-do-something"},"C'mon, Do Something"),(0,r.kt)("p",null,"Now, you\u2019re probably thinking: \u201cCool, we can model data now but there is more to computer systems than just data.\u201d There is always some domain logic that needs to be implemented. In our case, we should definitely add some sanity checks. Like removing any experience in Rust and adding a \u201cGood sense of humor\u201d quality instead."),(0,r.kt)("p",null,"Can we do that? Yes, but since this blog post is already longer than the documentation for ",(0,r.kt)("inlineCode",{parentName:"p"},"http4s")," I will have to end it here and if this blog post gets enough views, I will write a part II."),(0,r.kt)("p",null,"I hope the content was at least mildly interesting and that you didn\u2019t take anything I wrote seriously. Especially type-level programming."),(0,r.kt)("p",null,"Medium link: ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/virtuslab/data-modeling-in-scala-3-but-i-only-use-types-b6f11ead4c28"},"https://medium.com/virtuslab/data-modeling-in-scala-3-but-i-only-use-types-b6f11ead4c28")))}m.isMDXComponent=!0}}]);