"use strict";(self.webpackChunkkacperfkorban_github_io=self.webpackChunkkacperfkorban_github_io||[]).push([[648],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=p(a),d=l,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||i;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,o=new Array(i);o[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},6192:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return c},toc:function(){return u},default:function(){return d}});var n=a(7462),l=a(3366),i=(a(7294),a(3905)),o=["components"],r={slug:"Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study",title:"Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study",authors:"k\u03c0",tags:["scala","scala 3"]},s="Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study",p={permalink:"/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study",editUrl:"https://github.com/KacperFKorban/kacperfkorban.github.io/blog/2022-02-14-Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study.md",source:"@site/blog/2022-02-14-Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study.md",title:"Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study",description:"Disclaimer",date:"2022-02-14T00:00:00.000Z",formattedDate:"February 14, 2022",tags:[{label:"scala",permalink:"/blog/tags/scala"},{label:"scala 3",permalink:"/blog/tags/scala-3"}],readingTime:10.77,truncated:!1,authors:[{name:"Kacper Korban",url:"https://github.com/KacperFKorban",imageURL:"https://avatars.githubusercontent.com/u/39772805?v=4",key:"k\u03c0"}],prevItem:{title:"Data Modeling in Scala 3, but I only use types",permalink:"/blog/Data Modeling in Scala 3, but I only use types"},nextItem:{title:"TASTY way of (re)writing macros in Scala 3",permalink:"/blog/TASTY-way-of-rewriting-macros-in-Scala-3"}},c={authorsImageUrls:[void 0]},u=[{value:"Disclaimer",id:"disclaimer",children:[{value:"Running the examples",id:"running-the-examples",children:[],level:3}],level:2},{value:"Hello World",id:"hello-world",children:[{value:"The good stuff",id:"the-good-stuff",children:[],level:3},{value:"Abstract tree",id:"abstract-tree",children:[],level:3}],level:2},{value:"Not so simple algebra",id:"not-so-simple-algebra",children:[{value:"Vanilla",id:"vanilla",children:[],level:3},{value:"No value calculations",id:"no-value-calculations",children:[],level:3},{value:"Manual labor",id:"manual-labor",children:[],level:3}],level:2},{value:"Conclusions",id:"conclusions",children:[],level:2}],m={toc:u};function d(e){var t=e.components,r=(0,l.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"disclaimer"},"Disclaimer"),(0,i.kt)("p",null,"Most of the article is to be perceived as a joke or satire.\nThe post is intended as a light read. If you manage to get any educational value from it, you will most likely also enjoy reading the ingredients list of 2% milk.\nEnjoy!"),(0,i.kt)("h1",{id:"intro"},"Intro"),(0,i.kt)("p",null,"We computer programmers frequently state that we code because it is our passion, or because we enjoy building things, or for some other fanciful reason. At the end of the day, though, all Software Engineers write code to make money. This has been on my mind quite a bit lately. So I did some market research and analysis, and after crunching all the figures, I put my findings into this graphic."),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(3529).Z})),(0,i.kt)("p",null,"There it is plain and simple. You can clearly see that having a job has a huge impact on the amount of money you make. This is where Scala 3 comes in. We will employ Scala 3 to ensure complete job security. How are we going to do that? It\u2019s easy! By making the code impossible to read. If no one else can maintain, let alone read, our code, we will never get fired!\nIn this article, I will use the most straightforward programming problems like \u201cHello World\u201d or \u201cisPrime\u201d to demonstrate how you can master this essential skill."),(0,i.kt)("h3",{id:"running-the-examples"},"Running the examples"),(0,i.kt)("p",null,"This might be a good time to say that since all the snippets in this blog post are GitHub Gists, you can run them using ",(0,i.kt)("a",{parentName:"p",href:"https://scala-cli.virtuslab.org/"},"scala-cli")," easily, using the command below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"> scala-cli run gist-url\n")),(0,i.kt)("h2",{id:"hello-world"},"Hello World"),(0,i.kt)("p",null,"Ok, let\u2019s start with the best-known coding \u201cproblem\u201d i.e. \u201cHello World\u201d. In Scala 3, the solution to this problem usually looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'@main\ndef main =\n  println("Hello World")\n')),(0,i.kt)("h3",{id:"the-good-stuff"},"The good stuff"),(0,i.kt)("p",null,"How do we make this simple code unreadable? Well, instead of writing the code explicitly, we can generate the code that prints the output? Sounds promising! After all, generating code isn't easy, right?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'import scala.quoted.*\n\ninline def helloWorld =\n  ${ helloWorldImpl }\n\ndef helloWorldImpl(using Quotes): Expr[Unit] =\n  \'{ println("Hello World") }\n')),(0,i.kt)("p",null,"Well, it turns out that it\u2019s really straightforward. We just add an inline method that calls an actual implementation. And the actual implementation is the quoted code from our previous solution."),(0,i.kt)("h3",{id:"abstract-tree"},"Abstract tree"),(0,i.kt)("p",null,"We've hit a minor obstacle. How can we get around it?\nThe biggest problem with our implementation is that what was generated is very obvious as we just quoted our code and spliced it.\nHow about we disallow quoted blocks then? That way, the generated code will be way more obscure.\nExactly what do we need to do here? First, we need to return something that is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Expr[Unit]")," and is semantically equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},'{ println("Hello World") }'),".\nThe main ways to construct ",(0,i.kt)("inlineCode",{parentName:"p"},"Expr")," are using helper functions in its companion object or creating an (Abstract syntax) ",(0,i.kt)("inlineCode",{parentName:"p"},"Tree")," and converting it to an ",(0,i.kt)("inlineCode",{parentName:"p"},"Expr"),"."),(0,i.kt)("p",null,"Yeah, right, ",(0,i.kt)("inlineCode",{parentName:"p"},"Expr's and "),"Tree's, we don't really care about the semantics. We know that our expression should be the same as quoted ",(0,i.kt)("inlineCode",{parentName:"p"},'println("Hello World")'),". So, let's do what software developers usually do: put a bunch of `println's in random places and hope for the best."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def helloWorldImpl(using Quotes): Expr[Unit] =\n  println('{ println(\"Hello World\") }.asTerm)\n  '{ () }\n")),(0,i.kt)("p",null,"After running it, at compile time we get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Inlined(Ident(helloworldMacro$package$),List(),Apply(Ident(println),List(Literal(Constant(Hello World)))))\n")),(0,i.kt)("p",null,"We can ignore the ",(0,i.kt)("inlineCode",{parentName:"p"},"Inlined")," because it means that the term we got was an inlined expression. The exciting part is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"Apply(Ident(println),List(Literal(Constant(Hello World))))\n")),(0,i.kt)("p",null,"So it\u2019s an ",(0,i.kt)("inlineCode",{parentName:"p"},"Apply")," which is a function application of ",(0,i.kt)("inlineCode",{parentName:"p"},"Ident(println)")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"List(Literal(Constant(Hello World)))"),". Great, let\u2019s try recreating it using Quotes API. So, let\u2019s construct an ",(0,i.kt)("inlineCode",{parentName:"p"},"Apply"),", along with \u2018Something\u2019 as the first argument and a list containing a string literal as the second:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'private def helloWorldImpl(using Quotes): Expr[Unit] =\n  import quotes.reflect.*\n\n  val tree = Apply(???, List(Literal(StringConstant("Hello World"))))\n\n  tree.asExprOf[Unit]\n')),(0,i.kt)("p",null,"It's a good start, but what about the ",(0,i.kt)("inlineCode",{parentName:"p"},"???"),"? Well\u2026 it has to be the reference of ",(0,i.kt)("inlineCode",{parentName:"p"},"println")," and from the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplyModule.apply"),", it has to be a ",(0,i.kt)("inlineCode",{parentName:"p"},"Term"),". From this, we can imply that what we are looking for is most likely ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref"),", which requires a Symbol."),(0,i.kt)("p",null,"The Symbol object has methods with a naming pattern beginning with ",(0,i.kt)("inlineCode",{parentName:"p"},"required"),", for example: ",(0,i.kt)("inlineCode",{parentName:"p"},"requiredClass"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"requiredMethod"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"requiredModule"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"requiredPackage")," and so on. Those methods let us 'summon' symbols of a specific type defined in the compilation unit or on the classpath. Seems great since we want a static method, right? Let's try."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'private def helloWorldImpl(using Quotes): Expr[Unit] =\n  import quotes.reflect.*\n\n  val prntln: Ref =\n    Symbol.requiredMethod("scala.Predef.println").pipe(Ref(_))\n\n  val tree = Apply(prntln, List(Literal(StringConstant("Hello world"))))\n\n  tree.asExprOf[Unit]\n')),(0,i.kt)("p",null,"Note: We use ",(0,i.kt)("inlineCode",{parentName:"p"},"pipe")," here, a function from ",(0,i.kt)("inlineCode",{parentName:"p"},"scala.util.chaining"),". Although the actual implementation is slightly different, it can be thought of like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"extension [A](a: A)\n  def pipe[B](f: A => B): B = f(a)\n")),(0,i.kt)("p",null,"If you see a similarity with ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," bash, then you\u2019re absolutely right. That\u2019s one of the inspirations for it. And If you see a resemblance with ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," from Haskell, then you should go out more often."),(0,i.kt)("p",null,"Right, we can now run it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"[error] ./main.scala:31:3: Exception occurred while executing macro expansion.\n[error] dotty.tools.dotc.core.TypeError: Failure to disambiguate overloaded reference with\n[error]   method println in object Predef: (x: Any): Unit  and\n[error]   method println in object Predef: (): Unit\n[error]     at dotty.tools.dotc.core.Denotations$MultiDenotation.suchThat(Denotations.scala:1244)\n[error]     at dotty.tools.dotc.core.Denotations$Denotation.requiredSymbol(Denotations.scala:297)\n[error]     at dotty.tools.dotc.core.Symbols$.requiredMethod(Symbols.scala:908)\n[error]     at scala.quoted.runtime.impl.QuotesImpl$reflect$Symbol$.requiredMethod(QuotesImpl.scala:2450)\n[error]     at scala.quoted.runtime.impl.QuotesImpl$reflect$Symbol$.requiredMethod(QuotesImpl.scala:2450)\n[error]     at tmp.tmp$package$.helloWorldImpl(tmp.scala:12)\n[error]     at tmp.tmp$package$.inline$helloWorldImpl(tmp.scala:9)\n")),(0,i.kt)("p",null,"Cool, we got some good old-fashioned compiler error, with many references to compiler internals in the stack trace. That\u2019s what we wanted to see.\nWell, except that after skipping the first line, the message is actually pretty reasonable. There simply are two functions named ",(0,i.kt)("inlineCode",{parentName:"p"},"println")," at this path. And the scaladoc confirms it:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(7097).Z})),(0,i.kt)("p",null,"That means that we cannot solve the problem that easily. But that\u2019s good. The more code, the less readable it becomes. If we cannot access the method itself, let\u2019s access the owner first and get the method from the list of its members. The way we do that is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'Symbol.required("scala.Predef")\n')),(0,i.kt)("p",null,"Get its member methods named \u2018println\u2019..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'  .memberMethod("println")\n')),(0,i.kt)("p",null,"Then filter out the methods with no arguments\u2026"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  .flatMap { m =>\n    m.tree match\n      case defdef: DefDef\n        if !defdef.paramss.flatMap(_.params).isEmpty => Some(m)\n      case _ => None\n  }\n")),(0,i.kt)("p",null,"And finally, just take the ",(0,i.kt)("inlineCode",{parentName:"p"},"head")," of the list and wrap it in ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref"),"..."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"  .head.pipe(Ref(_))\n")),(0,i.kt)("p",null,"Cool. So, after composing it into our previous template, we get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},'private def helloWorldImpl(using Quotes): Expr[Unit] =\n  import quotes.reflect.*\n\n  val prntln = Symbol.requiredPackage("scala.Predef")\n    .memberMethod("println")\n    .flatMap { m =>\n      m.tree match\n        case defdef: DefDef\n          if !defdef.paramss.flatMap(_.params).isEmpty => Some(m)\n        case _ => None\n    }.head.pipe(Ref(_))\n\n  val tree = Apply(prntln, List(Literal(StringConstant("Hello world"))))\n\n  tree.asExprOf[Unit]\n')),(0,i.kt)("p",null,"And testing it gives us\u2026"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> scala-cli run ...\nHello World\n")),(0,i.kt)("p",null,"Great! And just like that, we were able to utilize metaprogramming to write confusing and unmaintainable code."),(0,i.kt)("h2",{id:"not-so-simple-algebra"},"Not so simple algebra"),(0,i.kt)("p",null,"Since we've already done quite a few Hello-Worlds. Let's change things up a bit now. Several well-known problems are usually used to learn recursion, e.g. the Fibonacci sequence, factorial, greatest common divisor, is prime, etc. Let's pick one at random; let's choose is prime."),(0,i.kt)("p",null,'Now you may start asking yourself: "How can I really be sure that it\'s actually at random?".\nAnd my answer to you would be: "My blog post, my rules. So if I say that it\'s random, then it\'s random, ok?"'),(0,i.kt)("h3",{id:"vanilla"},"Vanilla"),(0,i.kt)("p",null,"Let\u2019s implement the standard version as a warm-up."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def isPrimeCheat(a: Int): Boolean =\n  2.until(a).forall(a % _ != 0)\n")),(0,i.kt)("p",null,"Looks okay, right? RIGHT?! Of course not. I mean\u2026 it correctly checks if a number is prime, I\u2019ll give you that. But we said that it\u2019s an exercise for recursion. And do you see any recursion here? Let\u2019s fix it then."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"def isPrime(a: Int, acc: Int = 2): Boolean =\n  if a <= acc then a == acc\n  else a % acc != 0 && isPrime(a, acc+1)\n")),(0,i.kt)("p",null,"See? It looks better now."),(0,i.kt)("h3",{id:"no-value-calculations"},"No value calculations"),(0,i.kt)("p",null,"Now that the warm-up is over, how do we make this unreadable? How about disallowing the use of values? Sounds great, but can we make it work?\nThe answer is obviously yes; we can use types.\nScala 3 has a pretty impressive type system that can operate on singleton types. We can say that the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is a subtype of ",(0,i.kt)("inlineCode",{parentName:"p"},"Int"),". Cool right?\nWe also know that there is a pretty comprehensive set of type families (functions on type-level) that let us operate on singleton types. This means that we can almost rewrite our standard implementation 1:1. A reasonable attempt will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.compiletime.ops.int.*\n\ntype IsPrime[A <: Int] = IsPrimeRec[A, 2]\n\ntype IsPrimeRec[A <: Int, B <: Int] <: Boolean = A <= B match\n  case true => A == B\n  case false => A % B != 0 && IsPrimeRec[A, S[B]]\n")),(0,i.kt)("p",null,"First of all, we cannot have default parameters, so we will have to create a proxy function that calls our actual implementation. Then when we look at the actual definition, it is really similar to what we wrote on the value level. The only difference is that we used a match instead of an if statement. And that\u2019s because Scala has match types, but there is no such thing as if-else types."),(0,i.kt)("p",null,"You might be thinking now: \u201cHold on a sec. How are we going to print the result if it\u2019s a type?\u201d.\nFirst of all: Ok, smarty-pants. And secondly, we can use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"constValue")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"scala.compiletime"),", which lets us summon values of a given type if the type has a single decidable inhabitant. Like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.compiletime.*\n\n@main\ndef main =\n  println(constValue[IsPrime[13]])\n  println(constValue[IsPrime[12]])\n")),(0,i.kt)("p",null,"So when we run it, we get:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"> scala-cli run ...\ntrue\nfalse\n")),(0,i.kt)("p",null,"Success!"),(0,i.kt)("h3",{id:"manual-labor"},"Manual labor"),(0,i.kt)("p",null,"What did we learn from our exercise just now? Scala 3 makes type-level programming (at least for chosen types) way too easy. Mainly, that's because there are so many util functions. That's right, you know what's coming. Let\u2019s limit our usage of functions from ",(0,i.kt)("inlineCode",{parentName:"p"},"scala.compiletime.ops.int")," to just ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),".\nIf you don't know what ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," does, let me explain. It's a type-level successor function for integers. So e.g. S","[0]"," = 1, S","[1]"," = 2 and so on.\nAnd why did we choose ",(0,i.kt)("inlineCode",{parentName:"p"},"S")," in the first place? That's because, together with the literal ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", it works just like the definition of an inductive set for natural numbers. And since all of our operations are only required to work on natural numbers, we're going to implement them that way, so it's undefined behaviour for negative numbers."),(0,i.kt)("p",null,"Since the only thing that has to change is the declarations of the helper function, the actual implementation can stay as it was."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type IsPrimeRec[A <: Int, B <: Int] <: Boolean = A <= B match\n  case true => A == B\n  case false => A % B != 0 && IsPrimeRec[A, S[B]]\n")),(0,i.kt)("p",null,"What function do we need to implement first? Looks like it\u2019s going to be ",(0,i.kt)("inlineCode",{parentName:"p"},"<="),". Since we are implementing it for natural numbers, it seems obvious that the implementation has to follow their inductive definition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type <=[A <: Int, B <: Int] <: Boolean = A match\n  case 0 => true\n  case S[a] =>\n    B match\n      case 0 => false\n      case S[b] => a <= b\n")),(0,i.kt)("p",null,"It's pretty simple:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," is zero then it is smaller or equal to any natural number"),(0,i.kt)("li",{parentName:"ul"},"otherwise ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," is a successor of any ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),", so:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"if ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," is zero then it cannot be larger or equal than ",(0,i.kt)("inlineCode",{parentName:"li"},"S[a]")),(0,i.kt)("li",{parentName:"ul"},"otherwise ",(0,i.kt)("inlineCode",{parentName:"li"},"B")," is a successor of any ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," and we check if their predecessors satisfy the predicate.")))),(0,i.kt)("p",null,"Let's do the % next. This one is also pretty simple and looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"type %[A <: Int, B <: Int] <: Int = A < B match\n  case true => A\n  case _ => (A - B) % B\n")),(0,i.kt)("p",null,"Nothing exciting going on here. If A is smaller than B, just return B; otherwise, return (A-B) % B."),(0,i.kt)("p",null,"The rest of the functions are left as an exercise for the reader, but let\u2019s check if it works?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"> scala-cli run ...\ntrue\nfalse\n")),(0,i.kt)("h2",{id:"conclusions"},"Conclusions"),(0,i.kt)("p",null,"So, what did we learn from this article? Mainly that, in Scala 3, even code that's meant to be complicated isn't actually that bad. And writing unreadable code requires some skill."),(0,i.kt)("p",null,"So, why not use some of the languages that are unmaintainable by definition, like Rust or Python?\nIn the case of Rust, it is pretty easy: nobody actually uses Rust; people just like talking about using Rust.\nAnd when it comes to Python, the problem is that every program in Python is unmaintainable, and we wanted to write code that is readable only to us."),(0,i.kt)("p",null,"Medium link: ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/virtuslab/achieving-indisputable-job-security-using-novel-scala-3-features-a-case-study-65180eab810a"},"https://medium.com/virtuslab/achieving-indisputable-job-security-using-novel-scala-3-features-a-case-study-65180eab810a")))}d.isMDXComponent=!0},7097:function(e,t,a){t.Z=a.p+"assets/images/image1-8ef6b297427f9d9fa5bd6762e6e323f3.png"},3529:function(e,t,a){t.Z=a.p+"assets/images/image2-1eaf251f06fe8756ec822d72940326b9.png"}}]);