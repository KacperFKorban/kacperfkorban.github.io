"use strict";(self.webpackChunkkacperfkorban_github_io=self.webpackChunkkacperfkorban_github_io||[]).push([[852],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return h}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var i=n.createContext({}),p=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),h=o,d=u["".concat(i,".").concat(h)]||u[h]||m[h]||r;return a?n.createElement(d,l(l({ref:t},c),{},{components:a})):n.createElement(d,l({ref:t},c))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,l=new Array(r);l[0]=u;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:o,l[1]=s;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3724:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return p},assets:function(){return c},toc:function(){return m},default:function(){return h}});var n=a(7462),o=a(3366),r=(a(7294),a(3905)),l=["components"],s={slug:"TASTY-way-of-rewriting-macros-in-Scala-3",title:"TASTY way of (re)writing macros in Scala 3",authors:"k\u03c0",tags:["scala","scala 3"]},i="TASTY way of (re)writing macros in Scala 3",p={permalink:"/blog/TASTY-way-of-rewriting-macros-in-Scala-3",editUrl:"https://github.com/KacperFKorban/kacperfkorban.github.io/blog/2021-04-29-TASTY-way-of-rewriting-macros-in-Scala-3.md",source:"@site/blog/2021-04-29-TASTY-way-of-rewriting-macros-in-Scala-3.md",title:"TASTY way of (re)writing macros in Scala 3",description:"Intro",date:"2021-04-29T00:00:00.000Z",formattedDate:"April 29, 2021",tags:[{label:"scala",permalink:"/blog/tags/scala"},{label:"scala 3",permalink:"/blog/tags/scala-3"}],readingTime:7.425,truncated:!1,authors:[{name:"Kacper Korban",url:"https://github.com/KacperFKorban",imageURL:"https://avatars.githubusercontent.com/u/39772805?v=4",key:"k\u03c0"}],prevItem:{title:"Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study",permalink:"/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study"},nextItem:{title:"How to write Hoogle for Kotlin in Scala (and Scala.js)",permalink:"/blog/How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js"}},c={authorsImageUrls:[void 0]},m=[{value:"Intro",id:"intro",children:[],level:2},{value:"Problem",id:"problem",children:[],level:2},{value:"Base",id:"base",children:[],level:2},{value:"Code &lt;3",id:"code-3",children:[],level:2},{value:"Takeaways",id:"takeaways",children:[],level:2}],u={toc:m};function h(e){var t=e.components,a=(0,o.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"intro"},"Intro"),(0,r.kt)("p",null,"If you have decided to read this blog post, you probably used or at least heard of macros. But just to make sure that we are on the same page: Macros / metaprogramming in Scala provide a way to either generate scala code at compile-time or analyze existing code to gather syntactic data."),(0,r.kt)("p",null,"Since the interface for writing macros in Scala 3 is completely different from that of Scala 2, macro libraries should become easier to develop and maintain. It also means that macro libraries from Scala 2 can\u2019t be easily migrated or ported and instead have to be rewritten using the new TASTY API."),(0,r.kt)("p",null,"The aim of this blog post is to serve as a manual on efficiently using and navigating through Quotes API (which is the core of metaprogramming), rather than being a migration guide for macros or Scala projects in general. So for some preface/further reading macros documentation can be found ",(0,r.kt)("a",{parentName:"p",href:"https://docs.scala-lang.org/scala3/guides/macros/macros.html"},"here")," and the migration guide is ",(0,r.kt)("a",{parentName:"p",href:"https://scalacenter.github.io/scala-3-migration-guide/"},"here"),". There is also quite a powerful tool ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scalacenter/scala3-migrate"},"scala3-migrate"),", which automated most of the migration work."),(0,r.kt)("p",null,"All code snippets as well as the example mini-project were tested on Scala versions 3.0.0-RC1 and 3.0.0-RC2."),(0,r.kt)("h2",{id:"problem"},"Problem"),(0,r.kt)("p",null,"I strongly believe that the best way to learn is by example. So let\u2019s formulate a problem so that we have something to solve (because that\u2019s how real life works). Let\u2019s create a program that for a class (of kind ",(0,r.kt)("em",{parentName:"p"}," -> "),"), generates a neat type description for it, so for a case class like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"case class NonEmpty[T](e: T, tail: Option[NonEmpty[T]])\n")),(0,r.kt)("p",null,"we want to generate a string like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'"NonEmpty(e: T, tail: Option[NonEmpty[T]])"\n')),(0,r.kt)("h2",{id:"base"},"Base"),(0,r.kt)("p",null,"Like the title of the article suggests, we are going to be using TASTY reflect. So let\u2019s start by creating an empty object for our code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"import scala.quoted.*\n\nobject TypeInfo {\n inline def apply[T[_]]: String = ${ typeInfoImpl[T] }\n\n def typeInfoImpl[T[_]: Type](using Quotes): Expr[String] = {\n   import quotes.reflect.*\n\n   ???\n }\n}\n")),(0,r.kt)("p",null,"Let\u2019s take a look at what is going on here. First, we import scala.quoted.* to have access to Type and Quotes. Then we have the apply method. It only takes a single type parameter because our code isn\u2019t supposed to depend on the value, but rather on the given type. The body of apply is just ",(0,r.kt)("a",{parentName:"p",href:"https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html"},"spliced")," value of typeInfoImpl. When it comes to typeInfoImpl declaration, it takes the same type parameter and two implicit arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"qctx (short for Quotes Context) - gives us access to reflect API"),(0,r.kt)("li",{parentName:"ul"},"tpe - type information of the type parameter\nwhile returning a value of type Expr","[String]",", which after splicing yields a String.")),(0,r.kt)("h2",{id:"code-3"},"Code <3"),(0,r.kt)("p",null,"Cool, so now that we have a base, we can start writing actual code. Let\u2019s start with something simple, like just getting the class\u2019s name."),(0,r.kt)("p",null,"Our starting point is the tpe value, but in order to get the data we need, we have to transform this Type","[T]"," into something from TASTY reflect. Let\u2019s take a look at the hierarchy in ",(0,r.kt)("a",{parentName:"p",href:"https://dotty.epfl.ch/api/scala/quoted/Quotes$reflectModule.html"},"dotty/Quotes.scala")," then. The important part is this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"+- TypeRepr -+- NamedType -+- TermRef\n             |             +- TypeRef\n             +- ConstantType\n")),(0,r.kt)("p",null,"So we know that we need a TypeRepr, but in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/lampepfl/dotty/blob/main/library/src/scala/quoted/Quotes.scala"},"Quotes")," file there are no functions that may allow us to do it. That\u2019s because all methods and functions for operating on TASTY types are in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuotesImpl.scala"},"QuotesImpl.scala"),". The basic structure in this file is that for every AST node there are three main entries:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"type alias for the internal node type"),(0,r.kt)("li",{parentName:"ul"},"companion object, which implements constructor functions like apply, but also methods like unapply and copy"),(0,r.kt)("li",{parentName:"ul"},"given with extension methods for our type. The name of this given is always type_name + \u201cMethods\u201d\nSo the relevant entries for TyprRepr are:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"type TypeRepr = dotc.core.Types.Type\n\nobject TypeRepr extends TypeReprModule:\n ...\n def of[T <: AnyKind](using tp: scala.quoted.Type[T]): TypeRepr =\n   tp.asInstanceOf[TypeImpl].typeTree.$tpe\n ...\nend TypeRepr\n\ngiven TypeReprMethods: TypeReprMethods with\n extension (self: TypeRepr)\n   ...\n   def typeSymbol: Symbol = self.typeSymbol\n   ...\n end extension\nend TypeReprMethods\n")),(0,r.kt)("p",null,"Great, now we have a TypeRepr. Unfortunately, it doesn\u2019t have any methods that can give us access to the type\u2019s name, to get that information we have to access typeSymbol. After looking through the extension methods in SymbolMethods we can find the method name, which is exactly what we are looking for. Our very much WIP code looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"val tpe = TypeRepr.of[T]\nval name = tpe.typeSymbol.name\nExpr(name)\n")),(0,r.kt)("p",null,"Now that we have the basics covered, it\u2019s time to handle value parameters. Once again, we start with tpe of type TypeRepr. We want to access the type declaration, so we have to get typeSymbol. After looking in SymbolMethods for something that can get us case declarations of the class, we can find:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"def caseFields: List[Symbol] = ...\n")),(0,r.kt)("p",null,"Which does exactly what we want.\nOur description displays the label and type for every parameter. Getting the label is simple because, just like T\u2019s name, we have a Symbol with the name method. Unfortunately, there is no method that can give us the type of a declaration straight from Symbol. That means we have to look into the AST tree, which can be accessed from Symbol with the method tree (who would have thought :D). Ok, so can we deduce what types of AST nodes are our Symbols? Let\u2019s try, by looking at the hierarchy in ",(0,r.kt)("a",{parentName:"p",href:"https://dotty.epfl.ch/api/scala/quoted/Quotes.html"},"Quotes"),". We can intuitively guess that our case declarations are some kinds of declarations :o. Here is the relevant piece then:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"+- Definition --+- ClassDef\n|               +- TypeDef\n|               +- DefDef\n|               +- ValDef\n")),(0,r.kt)("p",null,"Let\u2019s go through all the options one by one:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ClassDef is a definition of a class, so it obviously cannot be a case declaration"),(0,r.kt)("li",{parentName:"ul"},"TypeDef is a declaration of a type. Type parameters are of type TypeDef, but they aren\u2019t considered case fields"),(0,r.kt)("li",{parentName:"ul"},"DefDef is a definition of a method, which can\u2019t be a case field either"),(0,r.kt)("li",{parentName:"ul"},"ValDef is a value definition (or variable)- all case fields are of this type\nBased on that, we should match on ValDefs. Let\u2019s take a look at the code we have described so far.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val caseFields = tpe.typeSymbol.caseFields.map { s =>\n  val name = s.name\n  val tpe = s.tree match {\n    case v: ValDef =>\n      ???\n  }\n  s"$name: $tpe"\n}\n')),(0,r.kt)("p",null,"Cool, what can we get from our ValDef then? We don\u2019t have much choice here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"given ValDefMethods: ValDefMethods with\n  extension (self: ValDef)\n    def tpt: TypeTree = self.tpt\n    def rhs: Option[Term] = optional(self.rhs)\n  end extension\nend ValDefMethods\n")),(0,r.kt)("p",null,"Obviously, we want the TypeTree here and after looking at the TypeTreeMethods, there is only one method- tpe: TypeRepr. TypeRepr has a bunch of possible specific types we will have to look into in a second. But for now, let\u2019s do the same trick as we did in the very beginning to get the class name (.typeSymbol.name). Now our code looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'val tpe = TypeRepr.of[T]  \nval name = tpe.typeSymbol.name\n\nval caseFields = tpe.typeSymbol.caseFields.map { s =>\n  val name = s.name\n  val tpe = s.tree match {\n    case v: ValDef =>\n      v.tpt.tpe.typeSymbol.name\n  }\n  s"$name: $tpe"\n}\n\nExpr(\n  s"$name(${caseFields.mkString(",")})"\n)\n')),(0,r.kt)("p",null,"And it gives this output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'"NonEmpty(e: T,tail: Option)"\n')),(0,r.kt)("p",null,"Looks almost done. The only thing missing are the type parameters of Option. As I mentioned before, TypeRepr has many specific node types. So let\u2019s take a look at some of them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},"+- TypeRepr -+- NamedType -+- TermRef\n            |              +- TypeRef\n            +- AppliedType\n            +- AndOrType -+- AndType\n            |             +- OrType\n            ...\n")),(0,r.kt)("p",null,"There are more of them, so in a real-life scenario, we would have to handle all of them. But my example, my rules. Most of those types are structurally recursive, so will delegate our type extraction logic to a function. For every AST node type we can look for desired methods just like before. For NamedType there is a method name, for AppliedType we can just use unapply to get the tycon (Type Constructor) and args and so on. The result looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'def fullTypeName(tpe: TypeRepr): String = tpe match\n     case t: NamedType =>\n       t.name\n     case o: OrType =>\n       fullTypeName(o.left) + " | " + fullTypeName(o.right)\n     case o: AndType =>\n       fullTypeName(o.left) + " & " + fullTypeName(o.right)\n     case AppliedType(base, args) =>\n       fullTypeName(base) + args.map(fullTypeName).mkString("[", ",", "]")\n')),(0,r.kt)("p",null,"After using the function call in our main code. The result presents like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-scala"},'"NonEmpty(e: T,tail: Option[NonEmpty[T]])"\n')),(0,r.kt)("p",null,"Which is exactly what we wanted :D"),(0,r.kt)("h2",{id:"takeaways"},"Takeaways"),(0,r.kt)("p",null,"The examples shown in this article are intentionally straightforward, just to show the basic process of working with TASTY reflect API. But the main ideas I wanted to show are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Look for node types in ",(0,r.kt)("a",{parentName:"li",href:"https://dotty.epfl.ch/api/scala/quoted/Quotes.html"},"Quotes")),(0,r.kt)("li",{parentName:"ul"},"Look for implementation and methods in ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuotesImpl.scala"},"QuotesImpl")),(0,r.kt)("li",{parentName:"ul"},"Macros in dotty are way easier to write than in Scala 2")),(0,r.kt)("p",null,"Code for this example is available ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/KacperFKorban/tasty-macro-migration"},"here"),"."),(0,r.kt)("p",null,"Medium link: ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c"},"https://medium.com/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c")))}h.isMDXComponent=!0}}]);