"use strict";(self.webpackChunkkacperfkorban_github_io=self.webpackChunkkacperfkorban_github_io||[]).push([[133],{3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return p}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(a),p=i,m=d["".concat(s,".").concat(p)]||d[p]||h[p]||o;return a?n.createElement(m,r(r({ref:t},c),{},{components:a})):n.createElement(m,r({ref:t},c))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var u=2;u<o;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5572:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},assets:function(){return c},toc:function(){return h},default:function(){return p}});var n=a(7462),i=a(3366),o=(a(7294),a(3905)),r=["components"],l={slug:"How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js",title:"How to write Hoogle for Kotlin in Scala (and Scala.js)",authors:["k\u03c0","aratajczak"],tags:["scala","scalajs","hoogle","kotlin"]},s="How to write Hoogle for Kotlin in Scala (and Scala.js)",u={permalink:"/blog/How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js",editUrl:"https://github.com/KacperFKorban/kacperfkorban.github.io/blog/2021-01-14-How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js.md",source:"@site/blog/2021-01-14-How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js.md",title:"How to write Hoogle for Kotlin in Scala (and Scala.js)",description:"Motivation",date:"2021-01-14T00:00:00.000Z",formattedDate:"January 14, 2021",tags:[{label:"scala",permalink:"/blog/tags/scala"},{label:"scalajs",permalink:"/blog/tags/scalajs"},{label:"hoogle",permalink:"/blog/tags/hoogle"},{label:"kotlin",permalink:"/blog/tags/kotlin"}],readingTime:8.755,truncated:!1,authors:[{name:"Kacper Korban",url:"https://github.com/KacperFKorban",imageURL:"https://avatars.githubusercontent.com/u/39772805?v=4",key:"k\u03c0"},{name:"Andrzej Ratajczak",url:"https://github.com/BarkingBad",imageURL:"https://avatars.githubusercontent.com/u/32793002?v=4",key:"aratajczak"}],prevItem:{title:"TASTY way of (re)writing macros in Scala 3",permalink:"/blog/TASTY-way-of-rewriting-macros-in-Scala-3"}},c={authorsImageUrls:[void 0,void 0]},h=[{value:"Motivation",id:"motivation",children:[],level:2},{value:"Why Scala for Kotlin tooling?",id:"why-scala-for-kotlin-tooling",children:[],level:2},{value:"Gathering code data",id:"gathering-code-data",children:[],level:2},{value:"Actual search",id:"actual-search",children:[],level:2},{value:"HTTP Client",id:"http-client",children:[],level:2},{value:"What if we would like to embed the engine into the documentation itself?",id:"what-if-we-would-like-to-embed-the-engine-into-the-documentation-itself",children:[],level:2},{value:"Is it even possible?",id:"is-it-even-possible",children:[],level:2},{value:"So how does it work internally?",id:"so-how-does-it-work-internally",children:[],level:2},{value:"Why Scala.js and not RESTful service?",id:"why-scalajs-and-not-restful-service",children:[],level:2},{value:"Runtime efficiency test of JS and JVM",id:"runtime-efficiency-test-of-js-and-jvm",children:[],level:2},{value:"What if I would like to use it myself?",id:"what-if-i-would-like-to-use-it-myself",children:[],level:2}],d={toc:h};function p(e){var t=e.components,l=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"motivation"},"Motivation"),(0,o.kt)("p",null,"Programmers tend to use strongly typed languages for the safety in the runtime and their own comfort while developing applications. While using new dependency, they often have to browse the documentation by symbolic names of classes and functions. Oftentimes, they don\u2019t know the function name, but are convinced there must be a function somewhere that fits given type transformation. In this talk, we will focus on a prototype tool that lets you browse the docs using types as search keys in Kotlin. "),(0,o.kt)("p",null,"Once in a while every developer stumbles upon a code like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val list = listOf("Andrzej", "Filip", "Micha\u0142")\nreturn Pair(\n   list.filter { it.length <= 5 },\n   list.filter { it.length > 5 }\n)\n')),(0,o.kt)("p",null,"And then a thought comes in. This looks like something people might do a lot. It surely can be done in a shorter, more readable way. So, what do we know that can help us refactor this code? Well in order to replace this ",(0,o.kt)("inlineCode",{parentName:"p"},"Pair(list.filter(...), list.filter(...))")," we want a function that behaves like this:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"<T> List<T>.((T) -> Boolean) -> Pair<List<T>, List<T>>")),(0,o.kt)("p",null,"Ok, that\u2019s great, but we still are pretty much nowhere. And that\u2019s because we need this function\u2019s name to call it.\nHow would we conventionally do it? Well, we could use Dokka for stdlib and look through potential functions, but that can take a lot of time. Plus it is way too close to actual work and we (software developers) don\u2019t really like that.\nThat\u2019s where Inkuire comes in. Inkuire lets us search a library documentation with function signatures as search keys."),(0,o.kt)("p",null,"Oooo, by the way the function we are looking for is ",(0,o.kt)("inlineCode",{parentName:"p"},"partition"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(4987).Z})),(0,o.kt)("h2",{id:"why-scala-for-kotlin-tooling"},"Why Scala for Kotlin tooling?"),(0,o.kt)("p",null,"One can wonder: Why are you using Scala for Kotlin tooling? Those are actually two questions framed as one:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u201cWhy for Kotlin?\u201d - This one is really simple. As software developers we don\u2019t really like doing too much work. In case of gathering Kotlin source data, dokka can do a huge share of work for us. We just need to format the data and persist it. Additionally Kotlin has a way simpler type system than Scala (especially Scala3). Therefore, having Hoogle for Kotlin is like proof of concept for having a similar tool in Scala3 world. "),(0,o.kt)("li",{parentName:"ul"},"\u201cWhy in Scala?\u201d - The first reason is that Scala is a more mature language. Scala.js has better support and documentation than Kotlin/JS. The other reason is just our personal preference. Scala with the use of Cats and similar libraries allows us to write code in a more functional way and probably everyone can agree, that is the 2020 way to code.")),(0,o.kt)("h2",{id:"gathering-code-data"},"Gathering code data"),(0,o.kt)("p",null,"First of all, we need a lot of data about code. It\u2019s not plain data from source code but rather complete information about types provided by Kotlin compiler. Therefore we have to analyse sources before we can serialize them. Of course we could use descriptors analysis offered by JetBrains, but there is a more convenient way of doing that thanks to the recently released documentation tool - ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Kotlin/dokka"},"dokka"),". You can find out more about dokka ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Kotlin/dokka"},"here"),", but what you have to know is its powerful pluggability abilities that enable you to have all required data about Kotlin and Java sources enclosed in a very simple and intuitive API.\nIf you would like to use dokka to analyse your own sources, check out this ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/virtuslab/analyzing-kotlin-sources-just-got-simpler-48aa88e0cf0b"},"great article")," by Marcin Aman. "),(0,o.kt)("h2",{id:"actual-search"},"Actual search"),(0,o.kt)("p",null,"Once we have the data, it\u2019s time to use it to find our mystery function. The first thing we have to worry about is how to tell the engine what we want, in other words: what should be the format of the query. After reading the title and motivation, it shouldn\u2019t come as a surprise, that we want to search for a function with a specific ",(0,o.kt)("strong",{parentName:"p"},"signature"),", so our input is just going to be a Kotlin signature."),(0,o.kt)("p",null,"The first step in processing an input string is parsing the given text with a grammar that recognises Kotlin function signatures and then map it to our model. Ironically, searching through scala-parser-combinators with signatures as search keys would be really helpful, since the most commonly used functions from this library are: ",(0,o.kt)("inlineCode",{parentName:"p"},"^^"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"~"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"~>"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"|"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<~"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"^^^"),". All those seem pretty self explanatory, so I won\u2019t go into much detail about the parser itself. But if you\u2019d like to learn more about using scala-parser-combinators the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/scala/scala-parser-combinators/blob/main/docs/Getting_Started.md"},"getting started")," page is a nice starting point."),(0,o.kt)("p",null,"After parsing, we have our signature mapped into a more approachable form. So let\u2019s look at our application from the user's perspective. If I input a signature, let\u2019s say something like ",(0,o.kt)("inlineCode",{parentName:"p"},"String.(Int) -> Any"),". What functions do I want to see as the result? In other words what should be the relation between our input signature and the result signatures? Well, the easiest and most intuitive relation would be substitution. So for the given signature anything that can be used in its place should be fine. So a function like drop with a signature ",(0,o.kt)("inlineCode",{parentName:"p"},"String.(Int) -> String")," is a good fit, since it has the same input types and just a more specific return type. But a function like maxOf (",(0,o.kt)("inlineCode",{parentName:"p"},"Int.(Int) -> Int"),") doesn\u2019t fit, because clearly the receiver- ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," has nothing to do (in terms of subtyping) with the expected receiver ",(0,o.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,o.kt)("h2",{id:"http-client"},"HTTP Client"),(0,o.kt)("p",null,"What would be Inkuire without an easily-accessed, user friendly client? The most intuitive and the simplest to deploy on your own is a RESTful service. Inkuire offers a ready to use JAR container that lets you ship the engine locally or globally without much overhead. Graphic design is not our passion, but we did our best."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(3179).Z})),(0,o.kt)("p",null,"You can also try it yourself ",(0,o.kt)("a",{parentName:"p",href:"https://inkuire.herokuapp.com/query"},"here"),"."),(0,o.kt)("h2",{id:"what-if-we-would-like-to-embed-the-engine-into-the-documentation-itself"},"What if we would like to embed the engine into the documentation itself?"),(0,o.kt)("p",null,"Imagine that: you configure dokka for your own library. Your code is encouraging to use it functional-programming style, maybe has an ArrowKt as a dependency. You would like to ship your documentation as the HTML pages, but the default search bar in dokka\u2019s default template allows you to search by function names. It would be awesome, if users could browse the documentation using signatures as search keys. We thought the same. So we decided to enable that using Scala.js!"),(0,o.kt)("h2",{id:"is-it-even-possible"},"Is it even possible?"),(0,o.kt)("p",null,"Well, Scala.js always has been a dark horse of Scala. Many Scala developers remain unaware to these days that Scala.js exists. But it does. And has really good support from community libraries. The idea is: you can transpile your Scala code to JavaScript if all your dependencies can or you depend on stdlib. Luckily, many popular libraries guarantee that compatibility."),(0,o.kt)("p",null,(0,o.kt)("img",{src:a(7918).Z})),(0,o.kt)("p",null,"You can try it yourself ",(0,o.kt)("a",{parentName:"p",href:"http://inkuire.s3.eu-central-1.amazonaws.com/master/stdlib/latest/kotlin-stdlib/kotlin-stdlib/index.html"},"here"),"."),(0,o.kt)("h2",{id:"so-how-does-it-work-internally"},"So how does it work internally?"),(0,o.kt)("p",null,"The querying engine is pure. It has just an input signature and an output list of matching functions. Transpilation to JavaScript is as easy as a piece of cake. The JavaScript obtained from Scala code lets you call the matching function the same way you would call it from standard JVM target. The only thing missing is the way to bind function to the DOM search bar. Luckily, Scala.js provides a DOM API, so you can include all the logic in Scala code without writing a single line of JavaScript by yourself. Isn\u2019t it awesome?"),(0,o.kt)("h2",{id:"why-scalajs-and-not-restful-service"},"Why Scala.js and not RESTful service?"),(0,o.kt)("p",null,"Why did we decide to transpile the engine code into JavaScript and not use the previously stated RESTful server to delegate calls and present results? Mainly, because we can encapsulate the whole deployment process in one plugin. The user has not to bother with deploying the JAR with the engine. If he could ship docs generated by dokka, he is able to ship them with our plugin attached. This approach also removed the problem with having to update the data for the server with every release. The database is built with documentation, so it will always be in sync with it. The cost of adding the plugin to dokka isn\u2019t that big (memory wise), the JavaScript code itself has only a few MB and e.g. the JVM part of stdlib has 15MB."),(0,o.kt)("h2",{id:"runtime-efficiency-test-of-js-and-jvm"},"Runtime efficiency test of JS and JVM"),(0,o.kt)("p",null,"Is it worth using an engine running in your browser instead of a dedicated JVM? Let\u2019s see.\nThe criteria of the test are: time of engine processing and overall time for the user since he typed the signature till received results. The JVM tests have been conducted using Apache JMeter and JS with Selenium (Chrome runner). The table below shows results:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Platform"),(0,o.kt)("th",{parentName:"tr",align:null},"Avg engine processing time"),(0,o.kt)("th",{parentName:"tr",align:null},"Std engine processing time"),(0,o.kt)("th",{parentName:"tr",align:null},"Avg ovberall time"),(0,o.kt)("th",{parentName:"tr",align:null},"Std overall time"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"JVM"),(0,o.kt)("td",{parentName:"tr",align:null},"330.26 ms"),(0,o.kt)("td",{parentName:"tr",align:null},"26.64 ms"),(0,o.kt)("td",{parentName:"tr",align:null},"332 ms"),(0,o.kt)("td",{parentName:"tr",align:null},"25.65 ms")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"JS"),(0,o.kt)("td",{parentName:"tr",align:null},"1165.57 ms"),(0,o.kt)("td",{parentName:"tr",align:null},"100.98 ms"),(0,o.kt)("td",{parentName:"tr",align:null},"2170.31 ms"),(0,o.kt)("td",{parentName:"tr",align:null},"101.43 ms")))),(0,o.kt)("p",null,"As you can see, the JVM version is about 5 times faster than JS one. The additional 1 second in overall time in JS comes from the debounce time of the input field, so we can detect when the user starts typing. One could think, it\u2019s better to use RESTful service, however, the time latency is so relatively small, it is hard to experience inconvenience from waiting for the results, having the advantage of jumping directly to the exact documentation subpage."),(0,o.kt)("h2",{id:"what-if-i-would-like-to-use-it-myself"},"What if I would like to use it myself?"),(0,o.kt)("p",null,"Currently, we do not publish artifacts to remote repositories. If you would like to use Inkuire for your project here source code. Installation guide can be found in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/VirtusLab/Inkuire/blob/kotlin/README.md"},"readme"),". Note that Inkuire has two main drawbacks. One is not a fully integrated multiplatform - you have to choose arbitrarily which source sets you would like to query from. Also, there is still the problem with getting a full hierarchy tree of types declared in dependencies. The rule of thumb is the same as with Scala.js: To obtain a full hierarchy tree, you must provide types databases from all dependencies. We know that going recursively deeper in the dependencies tree and generating all types databases is a tedious job, but it\u2019s the only solution available right now. However, using a type database only for a given library will cause engine work heuristicly; it will give true and applicable results, though he won\u2019t see all possible substitutions, and you will not be able to use types that you know are higher in the inheritance tree."),(0,o.kt)("p",null,"Medium link: ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/virtuslab/how-to-write-hoogle-for-kotlin-in-scala-and-scala-js-8c98c1c303ff"},"https://medium.com/virtuslab/how-to-write-hoogle-for-kotlin-in-scala-and-scala-js-8c98c1c303ff")))}p.isMDXComponent=!0},4987:function(e,t,a){t.Z=a.p+"assets/images/image1-1adfeb0aa7eeaa0e5ecf442e537591f0.png"},3179:function(e,t,a){t.Z=a.p+"assets/images/image2-77f57d14ef781152c9a190fd614bd076.gif"},7918:function(e,t,a){t.Z=a.p+"assets/images/image3-0851917b7ef8e8ca06437d2a9ada8f92.gif"}}]);