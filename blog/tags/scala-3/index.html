<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="korban.dev RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="korban.dev Atom Feed"><title data-react-helmet="true">3 posts tagged with &quot;scala 3&quot; | korban.dev</title><meta data-react-helmet="true" property="og:title" content="3 posts tagged with &quot;scala 3&quot; | korban.dev"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kacperfkorban.github.io/blog/tags/scala-3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_tags_posts"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kacperfkorban.github.io/blog/tags/scala-3"><link data-react-helmet="true" rel="alternate" href="https://kacperfkorban.github.io/blog/tags/scala-3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kacperfkorban.github.io/blog/tags/scala-3" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.d05c7c29.css">
<link rel="preload" href="/assets/js/runtime~main.a33f34f5.js" as="script">
<link rel="preload" href="/assets/js/main.03abd14a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title">korban.dev</b></a><a class="navbar__item navbar__link" href="/aboutme">About Me</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">üåú</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">üåû</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-tags-post-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_q+wC thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_9G5K margin-bottom--md">Recent posts</div><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/Data Modeling in Scala 3, but I only use types">Data Modeling in Scala 3, but I only use types</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study">Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/TASTY-way-of-rewriting-macros-in-Scala-3">TASTY way of (re)writing macros in Scala 3</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js">How to write Hoogle for Kotlin in Scala (and Scala.js)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>3 posts tagged with &quot;scala 3&quot;</h1><a href="/blog/tags">View All Tags</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_d4p0" itemprop="headline"><a itemprop="url" href="/blog/Data Modeling in Scala 3, but I only use types">Data Modeling in Scala 3, but I only use types</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2022-06-06T00:00:00.000Z" itemprop="datePublished">June 6, 2022</time> ¬∑ <!-- -->8 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_8c0z"><div class="avatar margin-bottom--sm"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_9q7L" src="https://avatars.githubusercontent.com/u/39772805?v=4" alt="Kacper Korban"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Kacper Korban</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>That‚Äôs the whole idea.</p><p>We want to model data in Scala, but instead of using instances of classes at the term level, we want to use their type-constructors at the type level.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="recruitment-system">Recruitment system<a class="hash-link" href="#recruitment-system" title="Direct link to heading">‚Äã</a></h2><p>Let‚Äôs pick an example to help us visualize the whole process better, because just like a wise person once said ‚ÄúA picture is worth a thousand words‚Äù.</p><p>We will represent candidate profiles in a recruitment process for software engineering companies. Let‚Äôs start with the term model code and I‚Äôll walk you through it.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class Candidate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  experience: List[Experience],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  otherQualities: List[String]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case class Experience(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  duration: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  expLevel: ExpLevel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  company: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  technologies: List[String]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum ExpLevel:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Junior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Regular</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Senior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case CEO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export ExpLevel.*</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We can represent candidates by providing their:</p><ul><li>name ‚Äì just a String</li><li>experience history ‚Äì list of Experience entries</li><li>other qualities ‚Äì list of string</li></ul><p>And experience entry is represented by:</p><ul><li>duration ‚Äì number of months at the job</li><li>experience level ‚Äì enum value representing experience levels in IT</li><li>company name ‚Äì a String</li><li>technologies ‚Äì list of technologies used</li></ul><p>So if we were to create a very simplified profile using our model, it will look like this.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val candidate = Candidate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;John Paul&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Experience(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    29,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Junior,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;VirtusLab&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   &quot;Scala&quot; :: Nil</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ) :: Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;Motivated&quot; :: Nil</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Cool, nothing new so far.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="making-it-spicier">Making it spicier<a class="hash-link" href="#making-it-spicier" title="Direct link to heading">‚Äã</a></h2><p>That was some basic Scala. Now what we want to do: is to be able to have all this information on the type level.</p><p>You might be asking: We already declared a model in the previous section. Can‚Äôt we just use that one?
As expected, the answer is: No. That‚Äôs because Scala distinguishes terms from types. The previous model worked on the term level, and we want to do it on the type level. So, we will have to tweak it a bit.</p><p>To make our intentions 100% clear, we want to be able to declare a type like the following (or at least similar).</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type candidate = Candidate[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;John Paul&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Experience[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    29,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Junior,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;VirtusLab&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;Scala&quot; :: Nil</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ] :: Nil,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;Motivated&quot; :: Nil</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Let‚Äôs start our work with the most basic class and work our way up the dependency graph.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="experience-level">Experience level<a class="hash-link" href="#experience-level" title="Direct link to heading">‚Äã</a></h3><p>First, let‚Äôs look at <strong>ExpLevel</strong>. We declared it before as</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">enum ExpLevel:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Junior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Regular</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Senior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case CEO</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export ExpLevel.*</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>When we think about it, its type constructors carry the same amount of information as its data constructors, so we could leave it as it is.
There is a small problem with the current declaration though. When we want to access the type of <code>Junior</code> and use it as e.g. a type parameter for <code>List</code>, we cannot just say <code>List[Junior]</code>. That‚Äôs because there is no such type constructor as <code>Junior</code>. Instead, we will have to type <code>List[Junior.type]</code>. This can be quite annoying, specifically when it‚Äôs a part of the interface exposed to the user.
Is there a way to fix it then? Yes, and it‚Äôs actually quite simple. Just like by writing in Python I can force myself into a crippling depression, you can force Scala to generate classes for all our cases by just adding parentheses after the constructors. Then, those won‚Äôt just be values, but classes with empty constructors.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">enum ExpLevel:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Junior()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Regular()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case Senior()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case CEO()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">export ExpLevel.*</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Nice, on to the next one.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="experience">Experience<a class="hash-link" href="#experience" title="Direct link to heading">‚Äã</a></h3><p>Now that we fixed the <code>ExpLevel</code> data type, let‚Äôs move on to Experience. In the term model, it looked like this</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class Experience(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  duration: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  expLevel: ExpLevel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  company: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  technologies: List[String]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We want all of those term parameters to become type parameters, so let‚Äôs try just adding them.
The strategy will be, for every term parameter we will:</p><ol><li>create a type parameter with the same name</li><li>add a type constraint for it using &lt;: operator</li></ol><p>It is important that we use &lt;: here and not :. That is because, when used on types, the first one is semantically equivalent to ‚Äúis subtype of‚Äù and the latter means ‚Äúhas implicit instance of‚Äù.
Let‚Äôs take a look at the result of our transformation then.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class Experience[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  duration &lt;: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  expLevel &lt;: ExpLevel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  company &lt;: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  technologies &lt;: List[String]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">]()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>At first glance, it looks ok and it looks very similar to the term model. We have an entry for every parameter and the constraints are the same as before. But does it work? Well, no. If I were to play the role of a build tool, I would say that we have one warning and one error.</p><p>Let‚Äôs start with the warning. Take a look at this class and think, what does the <code>case</code> keyword give us here. Well, it gives us the <code>apply</code> function to our empty constructor, <code>getters</code> to our non-existent fields, the <code>unapply</code> function for a class we will never construct, and some other extremely useful methods.
Do you get the point? The <code>case</code> keyword here is just as useful as a cats-effect expert at Ziverge.</p><p>Cool. On to the error now. This one might not be as easy to spot. To make it easier, let‚Äôs look at how List is implemented. Skipping a lot of details, we have:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">sealed abstract class List[+A]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final case class :: [+A](head: A, next: List[A]) extends List[A]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case object Nil extends List[Nothing]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We have a supertype <code>List</code> and two type constructors <code>::</code> (cons) and <code>Nil</code>.
<code>Nil</code>, carries no information since it just symbolizes an empty list. No problem here.
But, when we take a look at <code>::</code>, it only has one type parameter. This would mean that it will only be able to carry the definition of one <code>String</code>.</p><p>Let‚Äôs create our own data structure then. To make it easier, it should only contain <code>String</code>s.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">sealed trait StrList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Nl extends StrList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class :|:[head &lt;: String, tail &lt;: StrList] extends StrList</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Voila. We just take a look at the definition of List and move every term parameter to type-level, like before.</p><p>If we put all the parts together, we get.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class Experience[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  duration &lt;: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  expLevel &lt;: ExpLevel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  company &lt;: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  technologies &lt;: StrList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="candidate">Candidate<a class="hash-link" href="#candidate" title="Direct link to heading">‚Äã</a></h3><p>Let‚Äôs take a look at our last class ‚Äì <code>Candidate</code>.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class Candidate(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  experience: List[Experience],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  otherQualities: List[String]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Right off the bat, we can spot similar problems as with <code>Experience</code> ‚Äì Lists. Fortunately, we already have a structure for type-level lists of Strings from before. This means that we just need lists of <code>Experience</code>s. We can declare it in a similar way as with lists of strings, right? Let‚Äôs try.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">sealed trait Experiences</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Empty extends Experiences</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class :+:[head &lt;: ???, tail &lt;: Experiences] extends Experiences</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Ok. This looks exactly like the <code>StrList</code> with some minor name changes. Why is there a question mark instead of the constraint of head? That‚Äôs because we cannot use <code>Experience</code> there. <code>Experience</code> is a type constructor that takes a non-empty parameter list. We would have to specify it on the spot.</p><p>Is there some trick we can use here? Or is Scala‚Äôs type system not expressive enough?
Of course, there is a workaround. It is also quite a common pattern. It‚Äôs every functional programmer‚Äôs biggest nightmare and every object-oriented programmer‚Äôs wet dream: <code>Inheritance</code>.</p><p>If we add a supertype to our <code>Experience</code> class, we can use it in every place where we would usually use a type and treat <code>Experience</code> as the implementation.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">sealed trait Exp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Experience[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">] extends Exp</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Is this solution pretty? No.
But as the tapeworm said: There was no other way.</p><p>Now that we have fixed this issue, there is nothing interesting anymore with transforming the <code>Candidate</code> class.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class Candidate[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  name &lt;: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  experience &lt;: Experiences,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  otherQualities &lt;: StrList</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="final-form">Final form<a class="hash-link" href="#final-form" title="Direct link to heading">‚Äã</a></h2><p>After all that work we can finally write our correct example instance.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type mystery = Candidate[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;John Paul&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Experience[</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    29,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Junior,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;VirtusLab&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;Scala&quot; :|: Nl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ] :+: Empty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &quot;Motivated&quot; :|: Nl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And it compiles, which means that it works!</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="cmon-do-something">C&#x27;mon, Do Something<a class="hash-link" href="#cmon-do-something" title="Direct link to heading">‚Äã</a></h2><p>Now, you‚Äôre probably thinking: ‚ÄúCool, we can model data now but there is more to computer systems than just data.‚Äù There is always some domain logic that needs to be implemented. In our case, we should definitely add some sanity checks. Like removing any experience in Rust and adding a ‚ÄúGood sense of humor‚Äù quality instead.</p><p>Can we do that? Yes, but since this blog post is already longer than the documentation for <code>http4s</code> I will have to end it here and if this blog post gets enough views, I will write a part II.</p><p>I hope the content was at least mildly interesting and that you didn‚Äôt take anything I wrote seriously. Especially type-level programming.</p><p>Medium link: <a href="https://medium.com/virtuslab/data-modeling-in-scala-3-but-i-only-use-types-b6f11ead4c28" target="_blank" rel="noopener noreferrer">https://medium.com/virtuslab/data-modeling-in-scala-3-but-i-only-use-types-b6f11ead4c28</a></p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_NBRY padding--none margin-left--sm"><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala">scala</a></li><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala-3">scala 3</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Data Modeling in Scala 3, but I only use types" href="/blog/Data Modeling in Scala 3, but I only use types"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_d4p0" itemprop="headline"><a itemprop="url" href="/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study">Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2022-02-14T00:00:00.000Z" itemprop="datePublished">February 14, 2022</time> ¬∑ <!-- -->11 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_8c0z"><div class="avatar margin-bottom--sm"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_9q7L" src="https://avatars.githubusercontent.com/u/39772805?v=4" alt="Kacper Korban"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Kacper Korban</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_y2LR" id="disclaimer">Disclaimer<a class="hash-link" href="#disclaimer" title="Direct link to heading">‚Äã</a></h2><p>Most of the article is to be perceived as a joke or satire.
The post is intended as a light read. If you manage to get any educational value from it, you will most likely also enjoy reading the ingredients list of 2% milk.
Enjoy!</p><header><h1>Intro</h1></header><p>We computer programmers frequently state that we code because it is our passion, or because we enjoy building things, or for some other fanciful reason. At the end of the day, though, all Software Engineers write code to make money. This has been on my mind quite a bit lately. So I did some market research and analysis, and after crunching all the figures, I put my findings into this graphic.</p><p><img src="/assets/images/image2-1eaf251f06fe8756ec822d72940326b9.png"></p><p>There it is plain and simple. You can clearly see that having a job has a huge impact on the amount of money you make. This is where Scala 3 comes in. We will employ Scala 3 to ensure complete job security. How are we going to do that? It‚Äôs easy! By making the code impossible to read. If no one else can maintain, let alone read, our code, we will never get fired!
In this article, I will use the most straightforward programming problems like ‚ÄúHello World‚Äù or ‚ÄúisPrime‚Äù to demonstrate how you can master this essential skill.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="running-the-examples">Running the examples<a class="hash-link" href="#running-the-examples" title="Direct link to heading">‚Äã</a></h3><p>This might be a good time to say that since all the snippets in this blog post are GitHub Gists, you can run them using <a href="https://scala-cli.virtuslab.org/" target="_blank" rel="noopener noreferrer">scala-cli</a> easily, using the command below.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; scala-cli run gist-url</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="hello-world">Hello World<a class="hash-link" href="#hello-world" title="Direct link to heading">‚Äã</a></h2><p>Ok, let‚Äôs start with the best-known coding ‚Äúproblem‚Äù i.e. ‚ÄúHello World‚Äù. In Scala 3, the solution to this problem usually looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def main =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(&quot;Hello World&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="the-good-stuff">The good stuff<a class="hash-link" href="#the-good-stuff" title="Direct link to heading">‚Äã</a></h3><p>How do we make this simple code unreadable? Well, instead of writing the code explicitly, we can generate the code that prints the output? Sounds promising! After all, generating code isn&#x27;t easy, right?</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">import scala.quoted.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inline def helloWorld =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ${ helloWorldImpl }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def helloWorldImpl(using Quotes): Expr[Unit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &#x27;{ println(&quot;Hello World&quot;) }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Well, it turns out that it‚Äôs really straightforward. We just add an inline method that calls an actual implementation. And the actual implementation is the quoted code from our previous solution.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="abstract-tree">Abstract tree<a class="hash-link" href="#abstract-tree" title="Direct link to heading">‚Äã</a></h3><p>We&#x27;ve hit a minor obstacle. How can we get around it?
The biggest problem with our implementation is that what was generated is very obvious as we just quoted our code and spliced it.
How about we disallow quoted blocks then? That way, the generated code will be way more obscure.
Exactly what do we need to do here? First, we need to return something that is of type <code>Expr[Unit]</code> and is semantically equivalent to <code>{ println(&quot;Hello World&quot;) }</code>.
The main ways to construct <code>Expr</code> are using helper functions in its companion object or creating an (Abstract syntax) <code>Tree</code> and converting it to an <code>Expr</code>.</p><p>Yeah, right, <code>Expr&#x27;s and </code>Tree&#x27;s, we don&#x27;t really care about the semantics. We know that our expression should be the same as quoted <code>println(&quot;Hello World&quot;)</code>. So, let&#x27;s do what software developers usually do: put a bunch of `println&#x27;s in random places and hope for the best.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def helloWorldImpl(using Quotes): Expr[Unit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(&#x27;{ println(&quot;Hello World&quot;) }.asTerm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &#x27;{ () }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>After running it, at compile time we get:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Inlined(Ident(helloworldMacro$package$),List(),Apply(Ident(println),List(Literal(Constant(Hello World)))))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>We can ignore the <code>Inlined</code> because it means that the term we got was an inlined expression. The exciting part is:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Apply(Ident(println),List(Literal(Constant(Hello World))))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>So it‚Äôs an <code>Apply</code> which is a function application of <code>Ident(println)</code> to <code>List(Literal(Constant(Hello World)))</code>. Great, let‚Äôs try recreating it using Quotes API. So, let‚Äôs construct an <code>Apply</code>, along with ‚ÄòSomething‚Äô as the first argument and a list containing a string literal as the second:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private def helloWorldImpl(using Quotes): Expr[Unit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import quotes.reflect.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tree = Apply(???, List(Literal(StringConstant(&quot;Hello World&quot;))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  tree.asExprOf[Unit]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>It&#x27;s a good start, but what about the <code>???</code>? Well‚Ä¶ it has to be the reference of <code>println</code> and from the definition of <code>ApplyModule.apply</code>, it has to be a <code>Term</code>. From this, we can imply that what we are looking for is most likely <code>Ref</code>, which requires a Symbol.</p><p>The Symbol object has methods with a naming pattern beginning with <code>required</code>, for example: <code>requiredClass</code>, <code>requiredMethod</code>, <code>requiredModule</code>, <code>requiredPackage</code> and so on. Those methods let us &#x27;summon&#x27; symbols of a specific type defined in the compilation unit or on the classpath. Seems great since we want a static method, right? Let&#x27;s try.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private def helloWorldImpl(using Quotes): Expr[Unit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import quotes.reflect.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val prntln: Ref =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Symbol.requiredMethod(&quot;scala.Predef.println&quot;).pipe(Ref(_))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tree = Apply(prntln, List(Literal(StringConstant(&quot;Hello world&quot;))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  tree.asExprOf[Unit]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Note: We use <code>pipe</code> here, a function from <code>scala.util.chaining</code>. Although the actual implementation is slightly different, it can be thought of like so:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">extension [A](a: A)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  def pipe[B](f: A =&gt; B): B = f(a)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>If you see a similarity with <code>|</code> bash, then you‚Äôre absolutely right. That‚Äôs one of the inspirations for it. And If you see a resemblance with <code>$</code> or <code>&amp;</code> from Haskell, then you should go out more often.</p><p>Right, we can now run it.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">[error] ./main.scala:31:3: Exception occurred while executing macro expansion.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error] dotty.tools.dotc.core.TypeError: Failure to disambiguate overloaded reference with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]   method println in object Predef: (x: Any): Unit  and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]   method println in object Predef: (): Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at dotty.tools.dotc.core.Denotations$MultiDenotation.suchThat(Denotations.scala:1244)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at dotty.tools.dotc.core.Denotations$Denotation.requiredSymbol(Denotations.scala:297)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at dotty.tools.dotc.core.Symbols$.requiredMethod(Symbols.scala:908)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at scala.quoted.runtime.impl.QuotesImpl$reflect$Symbol$.requiredMethod(QuotesImpl.scala:2450)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at scala.quoted.runtime.impl.QuotesImpl$reflect$Symbol$.requiredMethod(QuotesImpl.scala:2450)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at tmp.tmp$package$.helloWorldImpl(tmp.scala:12)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[error]     at tmp.tmp$package$.inline$helloWorldImpl(tmp.scala:9)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Cool, we got some good old-fashioned compiler error, with many references to compiler internals in the stack trace. That‚Äôs what we wanted to see.
Well, except that after skipping the first line, the message is actually pretty reasonable. There simply are two functions named <code>println</code> at this path. And the scaladoc confirms it:</p><p><img src="/assets/images/image1-8ef6b297427f9d9fa5bd6762e6e323f3.png"></p><p>That means that we cannot solve the problem that easily. But that‚Äôs good. The more code, the less readable it becomes. If we cannot access the method itself, let‚Äôs access the owner first and get the method from the list of its members. The way we do that is:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">Symbol.required(&quot;scala.Predef&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Get its member methods named ‚Äòprintln‚Äô...</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">  .memberMethod(&quot;println&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Then filter out the methods with no arguments‚Ä¶</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">  .flatMap { m =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m.tree match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case defdef: DefDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if !defdef.paramss.flatMap(_.params).isEmpty =&gt; Some(m)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case _ =&gt; None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And finally, just take the <code>head</code> of the list and wrap it in <code>Ref</code>...</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">  .head.pipe(Ref(_))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Cool. So, after composing it into our previous template, we get:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private def helloWorldImpl(using Quotes): Expr[Unit] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  import quotes.reflect.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val prntln = Symbol.requiredPackage(&quot;scala.Predef&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .memberMethod(&quot;println&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .flatMap { m =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      m.tree match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case defdef: DefDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          if !defdef.paramss.flatMap(_.params).isEmpty =&gt; Some(m)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case _ =&gt; None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }.head.pipe(Ref(_))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tree = Apply(prntln, List(Literal(StringConstant(&quot;Hello world&quot;))))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  tree.asExprOf[Unit]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And testing it gives us‚Ä¶</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; scala-cli run ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Great! And just like that, we were able to utilize metaprogramming to write confusing and unmaintainable code.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="not-so-simple-algebra">Not so simple algebra<a class="hash-link" href="#not-so-simple-algebra" title="Direct link to heading">‚Äã</a></h2><p>Since we&#x27;ve already done quite a few Hello-Worlds. Let&#x27;s change things up a bit now. Several well-known problems are usually used to learn recursion, e.g. the Fibonacci sequence, factorial, greatest common divisor, is prime, etc. Let&#x27;s pick one at random; let&#x27;s choose is prime.</p><p>Now you may start asking yourself: &quot;How can I really be sure that it&#x27;s actually at random?&quot;.
And my answer to you would be: &quot;My blog post, my rules. So if I say that it&#x27;s random, then it&#x27;s random, ok?&quot;</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="vanilla">Vanilla<a class="hash-link" href="#vanilla" title="Direct link to heading">‚Äã</a></h3><p>Let‚Äôs implement the standard version as a warm-up.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def isPrimeCheat(a: Int): Boolean =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2.until(a).forall(a % _ != 0)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Looks okay, right? RIGHT?! Of course not. I mean‚Ä¶ it correctly checks if a number is prime, I‚Äôll give you that. But we said that it‚Äôs an exercise for recursion. And do you see any recursion here? Let‚Äôs fix it then.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def isPrime(a: Int, acc: Int = 2): Boolean =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if a &lt;= acc then a == acc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  else a % acc != 0 &amp;&amp; isPrime(a, acc+1)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>See? It looks better now.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="no-value-calculations">No value calculations<a class="hash-link" href="#no-value-calculations" title="Direct link to heading">‚Äã</a></h3><p>Now that the warm-up is over, how do we make this unreadable? How about disallowing the use of values? Sounds great, but can we make it work?
The answer is obviously yes; we can use types.
Scala 3 has a pretty impressive type system that can operate on singleton types. We can say that the type of <code>1</code> is <code>1</code> and <code>1</code> is a subtype of <code>Int</code>. Cool right?
We also know that there is a pretty comprehensive set of type families (functions on type-level) that let us operate on singleton types. This means that we can almost rewrite our standard implementation 1:1. A reasonable attempt will look like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">import scala.compiletime.ops.int.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type IsPrime[A &lt;: Int] = IsPrimeRec[A, 2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type IsPrimeRec[A &lt;: Int, B &lt;: Int] &lt;: Boolean = A &lt;= B match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case true =&gt; A == B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case false =&gt; A % B != 0 &amp;&amp; IsPrimeRec[A, S[B]]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>First of all, we cannot have default parameters, so we will have to create a proxy function that calls our actual implementation. Then when we look at the actual definition, it is really similar to what we wrote on the value level. The only difference is that we used a match instead of an if statement. And that‚Äôs because Scala has match types, but there is no such thing as if-else types.</p><p>You might be thinking now: ‚ÄúHold on a sec. How are we going to print the result if it‚Äôs a type?‚Äù.
First of all: Ok, smarty-pants. And secondly, we can use the function <code>constValue</code> from <code>scala.compiletime</code>, which lets us summon values of a given type if the type has a single decidable inhabitant. Like so:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">import scala.compiletime.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">def main =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(constValue[IsPrime[13]])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(constValue[IsPrime[12]])</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>So when we run it, we get:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; scala-cli run ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Success!</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="manual-labor">Manual labor<a class="hash-link" href="#manual-labor" title="Direct link to heading">‚Äã</a></h3><p>What did we learn from our exercise just now? Scala 3 makes type-level programming (at least for chosen types) way too easy. Mainly, that&#x27;s because there are so many util functions. That&#x27;s right, you know what&#x27;s coming. Let‚Äôs limit our usage of functions from <code>scala.compiletime.ops.int</code> to just <code>S</code>.
If you don&#x27;t know what <code>S</code> does, let me explain. It&#x27;s a type-level successor function for integers. So e.g. S<!-- -->[0]<!-- --> = 1, S<!-- -->[1]<!-- --> = 2 and so on.
And why did we choose <code>S</code> in the first place? That&#x27;s because, together with the literal <code>0</code>, it works just like the definition of an inductive set for natural numbers. And since all of our operations are only required to work on natural numbers, we&#x27;re going to implement them that way, so it&#x27;s undefined behaviour for negative numbers.</p><p>Since the only thing that has to change is the declarations of the helper function, the actual implementation can stay as it was.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type IsPrimeRec[A &lt;: Int, B &lt;: Int] &lt;: Boolean = A &lt;= B match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case true =&gt; A == B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case false =&gt; A % B != 0 &amp;&amp; IsPrimeRec[A, S[B]]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>What function do we need to implement first? Looks like it‚Äôs going to be <code>&lt;=</code>. Since we are implementing it for natural numbers, it seems obvious that the implementation has to follow their inductive definition.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type &lt;=[A &lt;: Int, B &lt;: Int] &lt;: Boolean = A match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case 0 =&gt; true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case S[a] =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    B match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case 0 =&gt; false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case S[b] =&gt; a &lt;= b</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>It&#x27;s pretty simple:</p><ul><li>if <code>A</code> is zero then it is smaller or equal to any natural number</li><li>otherwise <code>A</code> is a successor of any <code>a</code>, so:<ul><li>if <code>B</code> is zero then it cannot be larger or equal than <code>S[a]</code></li><li>otherwise <code>B</code> is a successor of any <code>b</code> and we check if their predecessors satisfy the predicate.</li></ul></li></ul><p>Let&#x27;s do the % next. This one is also pretty simple and looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type %[A &lt;: Int, B &lt;: Int] &lt;: Int = A &lt; B match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case true =&gt; A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  case _ =&gt; (A - B) % B</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Nothing exciting going on here. If A is smaller than B, just return B; otherwise, return (A-B) % B.</p><p>The rest of the functions are left as an exercise for the reader, but let‚Äôs check if it works?</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; scala-cli run ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="conclusions">Conclusions<a class="hash-link" href="#conclusions" title="Direct link to heading">‚Äã</a></h2><p>So, what did we learn from this article? Mainly that, in Scala 3, even code that&#x27;s meant to be complicated isn&#x27;t actually that bad. And writing unreadable code requires some skill.</p><p>So, why not use some of the languages that are unmaintainable by definition, like Rust or Python?
In the case of Rust, it is pretty easy: nobody actually uses Rust; people just like talking about using Rust.
And when it comes to Python, the problem is that every program in Python is unmaintainable, and we wanted to write code that is readable only to us.</p><p>Medium link: <a href="https://medium.com/virtuslab/achieving-indisputable-job-security-using-novel-scala-3-features-a-case-study-65180eab810a" target="_blank" rel="noopener noreferrer">https://medium.com/virtuslab/achieving-indisputable-job-security-using-novel-scala-3-features-a-case-study-65180eab810a</a></p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_NBRY padding--none margin-left--sm"><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala">scala</a></li><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala-3">scala 3</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study" href="/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_d4p0" itemprop="headline"><a itemprop="url" href="/blog/TASTY-way-of-rewriting-macros-in-Scala-3">TASTY way of (re)writing macros in Scala 3</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-04-29T00:00:00.000Z" itemprop="datePublished">April 29, 2021</time> ¬∑ <!-- -->8 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_8c0z"><div class="avatar margin-bottom--sm"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_9q7L" src="https://avatars.githubusercontent.com/u/39772805?v=4" alt="Kacper Korban"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Kacper Korban</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_y2LR" id="intro">Intro<a class="hash-link" href="#intro" title="Direct link to heading">‚Äã</a></h2><p>If you have decided to read this blog post, you probably used or at least heard of macros. But just to make sure that we are on the same page: Macros / metaprogramming in Scala provide a way to either generate scala code at compile-time or analyze existing code to gather syntactic data.</p><p>Since the interface for writing macros in Scala 3 is completely different from that of Scala 2, macro libraries should become easier to develop and maintain. It also means that macro libraries from Scala 2 can‚Äôt be easily migrated or ported and instead have to be rewritten using the new TASTY API.</p><p>The aim of this blog post is to serve as a manual on efficiently using and navigating through Quotes API (which is the core of metaprogramming), rather than being a migration guide for macros or Scala projects in general. So for some preface/further reading macros documentation can be found <a href="https://docs.scala-lang.org/scala3/guides/macros/macros.html" target="_blank" rel="noopener noreferrer">here</a> and the migration guide is <a href="https://scalacenter.github.io/scala-3-migration-guide/" target="_blank" rel="noopener noreferrer">here</a>. There is also quite a powerful tool <a href="https://github.com/scalacenter/scala3-migrate" target="_blank" rel="noopener noreferrer">scala3-migrate</a>, which automated most of the migration work.</p><p>All code snippets as well as the example mini-project were tested on Scala versions 3.0.0-RC1 and 3.0.0-RC2.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="problem">Problem<a class="hash-link" href="#problem" title="Direct link to heading">‚Äã</a></h2><p>I strongly believe that the best way to learn is by example. So let‚Äôs formulate a problem so that we have something to solve (because that‚Äôs how real life works). Let‚Äôs create a program that for a class (of kind <em> -&gt; </em>), generates a neat type description for it, so for a case class like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class NonEmpty[T](e: T, tail: Option[NonEmpty[T]])</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>we want to generate a string like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;NonEmpty(e: T, tail: Option[NonEmpty[T]])&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="base">Base<a class="hash-link" href="#base" title="Direct link to heading">‚Äã</a></h2><p>Like the title of the article suggests, we are going to be using TASTY reflect. So let‚Äôs start by creating an empty object for our code.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">import scala.quoted.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object TypeInfo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> inline def apply[T[_]]: String = ${ typeInfoImpl[T] }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> def typeInfoImpl[T[_]: Type](using Quotes): Expr[String] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   import quotes.reflect.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ???</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Let‚Äôs take a look at what is going on here. First, we import scala.quoted.* to have access to Type and Quotes. Then we have the apply method. It only takes a single type parameter because our code isn‚Äôt supposed to depend on the value, but rather on the given type. The body of apply is just <a href="https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html" target="_blank" rel="noopener noreferrer">spliced</a> value of typeInfoImpl. When it comes to typeInfoImpl declaration, it takes the same type parameter and two implicit arguments:</p><ul><li>qctx (short for Quotes Context) - gives us access to reflect API</li><li>tpe - type information of the type parameter
while returning a value of type Expr<!-- -->[String]<!-- -->, which after splicing yields a String.</li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="code-3">Code &lt;3<a class="hash-link" href="#code-3" title="Direct link to heading">‚Äã</a></h2><p>Cool, so now that we have a base, we can start writing actual code. Let‚Äôs start with something simple, like just getting the class‚Äôs name.</p><p>Our starting point is the tpe value, but in order to get the data we need, we have to transform this Type<!-- -->[T]<!-- --> into something from TASTY reflect. Let‚Äôs take a look at the hierarchy in <a href="https://dotty.epfl.ch/api/scala/quoted/Quotes$reflectModule.html" target="_blank" rel="noopener noreferrer">dotty/Quotes.scala</a> then. The important part is this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">+- TypeRepr -+- NamedType -+- TermRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             |             +- TypeRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             +- ConstantType</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>So we know that we need a TypeRepr, but in the <a href="https://github.com/lampepfl/dotty/blob/main/library/src/scala/quoted/Quotes.scala" target="_blank" rel="noopener noreferrer">Quotes</a> file there are no functions that may allow us to do it. That‚Äôs because all methods and functions for operating on TASTY types are in <a href="https://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuotesImpl.scala" target="_blank" rel="noopener noreferrer">QuotesImpl.scala</a>. The basic structure in this file is that for every AST node there are three main entries:</p><ul><li>type alias for the internal node type</li><li>companion object, which implements constructor functions like apply, but also methods like unapply and copy</li><li>given with extension methods for our type. The name of this given is always type_name + ‚ÄúMethods‚Äù
So the relevant entries for TyprRepr are:</li></ul><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type TypeRepr = dotc.core.Types.Type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object TypeRepr extends TypeReprModule:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> def of[T &lt;: AnyKind](using tp: scala.quoted.Type[T]): TypeRepr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   tp.asInstanceOf[TypeImpl].typeTree.$tpe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end TypeRepr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">given TypeReprMethods: TypeReprMethods with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> extension (self: TypeRepr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   def typeSymbol: Symbol = self.typeSymbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> end extension</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end TypeReprMethods</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Great, now we have a TypeRepr. Unfortunately, it doesn‚Äôt have any methods that can give us access to the type‚Äôs name, to get that information we have to access typeSymbol. After looking through the extension methods in SymbolMethods we can find the method name, which is exactly what we are looking for. Our very much WIP code looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val tpe = TypeRepr.of[T]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val name = tpe.typeSymbol.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Expr(name)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Now that we have the basics covered, it‚Äôs time to handle value parameters. Once again, we start with tpe of type TypeRepr. We want to access the type declaration, so we have to get typeSymbol. After looking in SymbolMethods for something that can get us case declarations of the class, we can find:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def caseFields: List[Symbol] = ...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Which does exactly what we want.
Our description displays the label and type for every parameter. Getting the label is simple because, just like T‚Äôs name, we have a Symbol with the name method. Unfortunately, there is no method that can give us the type of a declaration straight from Symbol. That means we have to look into the AST tree, which can be accessed from Symbol with the method tree (who would have thought :D). Ok, so can we deduce what types of AST nodes are our Symbols? Let‚Äôs try, by looking at the hierarchy in <a href="https://dotty.epfl.ch/api/scala/quoted/Quotes.html" target="_blank" rel="noopener noreferrer">Quotes</a>. We can intuitively guess that our case declarations are some kinds of declarations :o. Here is the relevant piece then:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">+- Definition --+- ClassDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|               +- TypeDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|               +- DefDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|               +- ValDef</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Let‚Äôs go through all the options one by one:</p><ul><li>ClassDef is a definition of a class, so it obviously cannot be a case declaration</li><li>TypeDef is a declaration of a type. Type parameters are of type TypeDef, but they aren‚Äôt considered case fields</li><li>DefDef is a definition of a method, which can‚Äôt be a case field either</li><li>ValDef is a value definition (or variable)- all case fields are of this type
Based on that, we should match on ValDefs. Let‚Äôs take a look at the code we have described so far.</li></ul><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val caseFields = tpe.typeSymbol.caseFields.map { s =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val name = s.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tpe = s.tree match {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case v: ValDef =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ???</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s&quot;$name: $tpe&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Cool, what can we get from our ValDef then? We don‚Äôt have much choice here:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">given ValDefMethods: ValDefMethods with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extension (self: ValDef)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def tpt: TypeTree = self.tpt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def rhs: Option[Term] = optional(self.rhs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end extension</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end ValDefMethods</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Obviously, we want the TypeTree here and after looking at the TypeTreeMethods, there is only one method- tpe: TypeRepr. TypeRepr has a bunch of possible specific types we will have to look into in a second. But for now, let‚Äôs do the same trick as we did in the very beginning to get the class name (.typeSymbol.name). Now our code looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val tpe = TypeRepr.of[T]  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val name = tpe.typeSymbol.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val caseFields = tpe.typeSymbol.caseFields.map { s =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val name = s.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tpe = s.tree match {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case v: ValDef =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      v.tpt.tpe.typeSymbol.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s&quot;$name: $tpe&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Expr(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s&quot;$name(${caseFields.mkString(&quot;,&quot;)})&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And it gives this output:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;NonEmpty(e: T,tail: Option)&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Looks almost done. The only thing missing are the type parameters of Option. As I mentioned before, TypeRepr has many specific node types. So let‚Äôs take a look at some of them:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">+- TypeRepr -+- NamedType -+- TermRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |              +- TypeRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            +- AppliedType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            +- AndOrType -+- AndType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |             +- OrType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>There are more of them, so in a real-life scenario, we would have to handle all of them. But my example, my rules. Most of those types are structurally recursive, so will delegate our type extraction logic to a function. For every AST node type we can look for desired methods just like before. For NamedType there is a method name, for AppliedType we can just use unapply to get the tycon (Type Constructor) and args and so on. The result looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def fullTypeName(tpe: TypeRepr): String = tpe match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case t: NamedType =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       t.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case o: OrType =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       fullTypeName(o.left) + &quot; | &quot; + fullTypeName(o.right)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case o: AndType =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       fullTypeName(o.left) + &quot; &amp; &quot; + fullTypeName(o.right)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case AppliedType(base, args) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       fullTypeName(base) + args.map(fullTypeName).mkString(&quot;[&quot;, &quot;,&quot;, &quot;]&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>After using the function call in our main code. The result presents like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;NonEmpty(e: T,tail: Option[NonEmpty[T]])&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Which is exactly what we wanted :D</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="takeaways">Takeaways<a class="hash-link" href="#takeaways" title="Direct link to heading">‚Äã</a></h2><p>The examples shown in this article are intentionally straightforward, just to show the basic process of working with TASTY reflect API. But the main ideas I wanted to show are:</p><ul><li>Look for node types in <a href="https://dotty.epfl.ch/api/scala/quoted/Quotes.html" target="_blank" rel="noopener noreferrer">Quotes</a></li><li>Look for implementation and methods in <a href="https://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuotesImpl.scala" target="_blank" rel="noopener noreferrer">QuotesImpl</a></li><li>Macros in dotty are way easier to write than in Scala 2</li></ul><p>Code for this example is available <a href="https://github.com/KacperFKorban/tasty-macro-migration" target="_blank" rel="noopener noreferrer">here</a>.</p><p>Medium link: <a href="https://medium.com/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c" target="_blank" rel="noopener noreferrer">https://medium.com/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c</a></p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_NBRY padding--none margin-left--sm"><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala">scala</a></li><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala-3">scala 3</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about TASTY way of (re)writing macros in Scala 3" href="/blog/TASTY-way-of-rewriting-macros-in-Scala-3"><b>Read More</b></a></div></footer></article></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Content</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">Social media</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/KacperKorban" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2022 korban.dev, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a33f34f5.js"></script>
<script src="/assets/js/main.03abd14a.js"></script>
</body>
</html>