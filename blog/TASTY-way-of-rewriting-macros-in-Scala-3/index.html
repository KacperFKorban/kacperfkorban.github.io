<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="korban.dev RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="korban.dev Atom Feed"><title data-react-helmet="true">TASTY way of (re)writing macros in Scala 3 | korban.dev</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://kacperfkorban.github.io/blog/TASTY-way-of-rewriting-macros-in-Scala-3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="TASTY way of (re)writing macros in Scala 3 | korban.dev"><meta data-react-helmet="true" name="description" content="Intro"><meta data-react-helmet="true" property="og:description" content="Intro"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2021-04-29T00:00:00.000Z"><meta data-react-helmet="true" property="article:author" content="https://github.com/KacperFKorban"><meta data-react-helmet="true" property="article:tag" content="scala,scala 3"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://kacperfkorban.github.io/blog/TASTY-way-of-rewriting-macros-in-Scala-3"><link data-react-helmet="true" rel="alternate" href="https://kacperfkorban.github.io/blog/TASTY-way-of-rewriting-macros-in-Scala-3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://kacperfkorban.github.io/blog/TASTY-way-of-rewriting-macros-in-Scala-3" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.d05c7c29.css">
<link rel="preload" href="/assets/js/runtime~main.0de25d61.js" as="script">
<link rel="preload" href="/assets/js/main.bb8a9f9b.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title">korban.dev</b></a><a class="navbar__item navbar__link" href="/aboutme">About Me</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">üåú</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">üåû</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_q+wC thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_9G5K margin-bottom--md">Recent posts</div><ul class="sidebarItemList_6T4b"><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/Data Modeling in Scala 3, but I only use types">Data Modeling in Scala 3, but I only use types</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study">Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study</a></li><li class="sidebarItem_cjdF"><a aria-current="page" class="sidebarItemLink_zyXk sidebarItemLinkActive_wcJs" href="/blog/TASTY-way-of-rewriting-macros-in-Scala-3">TASTY way of (re)writing macros in Scala 3</a></li><li class="sidebarItem_cjdF"><a class="sidebarItemLink_zyXk" href="/blog/How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js">How to write Hoogle for Kotlin in Scala (and Scala.js)</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_d4p0" itemprop="headline">TASTY way of (re)writing macros in Scala 3</h1><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2021-04-29T00:00:00.000Z" itemprop="datePublished">April 29, 2021</time> ¬∑ <!-- -->8 min read</div><div class="row margin-top--md margin-bottom--sm"><div class="col col--6 authorCol_8c0z"><div class="avatar margin-bottom--sm"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img class="image_9q7L" src="https://avatars.githubusercontent.com/u/39772805?v=4" alt="Kacper Korban"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Kacper Korban</span></a></div></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_y2LR" id="intro">Intro<a class="hash-link" href="#intro" title="Direct link to heading">‚Äã</a></h2><p>If you have decided to read this blog post, you probably used or at least heard of macros. But just to make sure that we are on the same page: Macros / metaprogramming in Scala provide a way to either generate scala code at compile-time or analyze existing code to gather syntactic data.</p><p>Since the interface for writing macros in Scala 3 is completely different from that of Scala 2, macro libraries should become easier to develop and maintain. It also means that macro libraries from Scala 2 can‚Äôt be easily migrated or ported and instead have to be rewritten using the new TASTY API.</p><p>The aim of this blog post is to serve as a manual on efficiently using and navigating through Quotes API (which is the core of metaprogramming), rather than being a migration guide for macros or Scala projects in general. So for some preface/further reading macros documentation can be found <a href="https://docs.scala-lang.org/scala3/guides/macros/macros.html" target="_blank" rel="noopener noreferrer">here</a> and the migration guide is <a href="https://scalacenter.github.io/scala-3-migration-guide/" target="_blank" rel="noopener noreferrer">here</a>. There is also quite a powerful tool <a href="https://github.com/scalacenter/scala3-migrate" target="_blank" rel="noopener noreferrer">scala3-migrate</a>, which automated most of the migration work.</p><p>All code snippets as well as the example mini-project were tested on Scala versions 3.0.0-RC1 and 3.0.0-RC2.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="problem">Problem<a class="hash-link" href="#problem" title="Direct link to heading">‚Äã</a></h2><p>I strongly believe that the best way to learn is by example. So let‚Äôs formulate a problem so that we have something to solve (because that‚Äôs how real life works). Let‚Äôs create a program that for a class (of kind <em> -&gt; </em>), generates a neat type description for it, so for a case class like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">case class NonEmpty[T](e: T, tail: Option[NonEmpty[T]])</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>we want to generate a string like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;NonEmpty(e: T, tail: Option[NonEmpty[T]])&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="base">Base<a class="hash-link" href="#base" title="Direct link to heading">‚Äã</a></h2><p>Like the title of the article suggests, we are going to be using TASTY reflect. So let‚Äôs start by creating an empty object for our code.</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">import scala.quoted.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object TypeInfo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> inline def apply[T[_]]: String = ${ typeInfoImpl[T] }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> def typeInfoImpl[T[_]: Type](using Quotes): Expr[String] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   import quotes.reflect.*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ???</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Let‚Äôs take a look at what is going on here. First, we import scala.quoted.* to have access to Type and Quotes. Then we have the apply method. It only takes a single type parameter because our code isn‚Äôt supposed to depend on the value, but rather on the given type. The body of apply is just <a href="https://dotty.epfl.ch/docs/reference/metaprogramming/macros.html" target="_blank" rel="noopener noreferrer">spliced</a> value of typeInfoImpl. When it comes to typeInfoImpl declaration, it takes the same type parameter and two implicit arguments:</p><ul><li>qctx (short for Quotes Context) - gives us access to reflect API</li><li>tpe - type information of the type parameter
while returning a value of type Expr<!-- -->[String]<!-- -->, which after splicing yields a String.</li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="code-3">Code &lt;3<a class="hash-link" href="#code-3" title="Direct link to heading">‚Äã</a></h2><p>Cool, so now that we have a base, we can start writing actual code. Let‚Äôs start with something simple, like just getting the class‚Äôs name.</p><p>Our starting point is the tpe value, but in order to get the data we need, we have to transform this Type<!-- -->[T]<!-- --> into something from TASTY reflect. Let‚Äôs take a look at the hierarchy in <a href="https://dotty.epfl.ch/api/scala/quoted/Quotes$reflectModule.html" target="_blank" rel="noopener noreferrer">dotty/Quotes.scala</a> then. The important part is this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">+- TypeRepr -+- NamedType -+- TermRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             |             +- TypeRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             +- ConstantType</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>So we know that we need a TypeRepr, but in the <a href="https://github.com/lampepfl/dotty/blob/main/library/src/scala/quoted/Quotes.scala" target="_blank" rel="noopener noreferrer">Quotes</a> file there are no functions that may allow us to do it. That‚Äôs because all methods and functions for operating on TASTY types are in <a href="https://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuotesImpl.scala" target="_blank" rel="noopener noreferrer">QuotesImpl.scala</a>. The basic structure in this file is that for every AST node there are three main entries:</p><ul><li>type alias for the internal node type</li><li>companion object, which implements constructor functions like apply, but also methods like unapply and copy</li><li>given with extension methods for our type. The name of this given is always type_name + ‚ÄúMethods‚Äù
So the relevant entries for TyprRepr are:</li></ul><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">type TypeRepr = dotc.core.Types.Type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object TypeRepr extends TypeReprModule:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> def of[T &lt;: AnyKind](using tp: scala.quoted.Type[T]): TypeRepr =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   tp.asInstanceOf[TypeImpl].typeTree.$tpe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end TypeRepr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">given TypeReprMethods: TypeReprMethods with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> extension (self: TypeRepr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   def typeSymbol: Symbol = self.typeSymbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> end extension</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end TypeReprMethods</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Great, now we have a TypeRepr. Unfortunately, it doesn‚Äôt have any methods that can give us access to the type‚Äôs name, to get that information we have to access typeSymbol. After looking through the extension methods in SymbolMethods we can find the method name, which is exactly what we are looking for. Our very much WIP code looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val tpe = TypeRepr.of[T]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val name = tpe.typeSymbol.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Expr(name)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Now that we have the basics covered, it‚Äôs time to handle value parameters. Once again, we start with tpe of type TypeRepr. We want to access the type declaration, so we have to get typeSymbol. After looking in SymbolMethods for something that can get us case declarations of the class, we can find:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def caseFields: List[Symbol] = ...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Which does exactly what we want.
Our description displays the label and type for every parameter. Getting the label is simple because, just like T‚Äôs name, we have a Symbol with the name method. Unfortunately, there is no method that can give us the type of a declaration straight from Symbol. That means we have to look into the AST tree, which can be accessed from Symbol with the method tree (who would have thought :D). Ok, so can we deduce what types of AST nodes are our Symbols? Let‚Äôs try, by looking at the hierarchy in <a href="https://dotty.epfl.ch/api/scala/quoted/Quotes.html" target="_blank" rel="noopener noreferrer">Quotes</a>. We can intuitively guess that our case declarations are some kinds of declarations :o. Here is the relevant piece then:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">+- Definition --+- ClassDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|               +- TypeDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|               +- DefDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|               +- ValDef</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Let‚Äôs go through all the options one by one:</p><ul><li>ClassDef is a definition of a class, so it obviously cannot be a case declaration</li><li>TypeDef is a declaration of a type. Type parameters are of type TypeDef, but they aren‚Äôt considered case fields</li><li>DefDef is a definition of a method, which can‚Äôt be a case field either</li><li>ValDef is a value definition (or variable)- all case fields are of this type
Based on that, we should match on ValDefs. Let‚Äôs take a look at the code we have described so far.</li></ul><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val caseFields = tpe.typeSymbol.caseFields.map { s =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val name = s.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tpe = s.tree match {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case v: ValDef =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ???</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s&quot;$name: $tpe&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Cool, what can we get from our ValDef then? We don‚Äôt have much choice here:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">given ValDefMethods: ValDefMethods with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  extension (self: ValDef)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def tpt: TypeTree = self.tpt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    def rhs: Option[Term] = optional(self.rhs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  end extension</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">end ValDefMethods</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Obviously, we want the TypeTree here and after looking at the TypeTreeMethods, there is only one method- tpe: TypeRepr. TypeRepr has a bunch of possible specific types we will have to look into in a second. But for now, let‚Äôs do the same trick as we did in the very beginning to get the class name (.typeSymbol.name). Now our code looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">val tpe = TypeRepr.of[T]  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val name = tpe.typeSymbol.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val caseFields = tpe.typeSymbol.caseFields.map { s =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val name = s.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val tpe = s.tree match {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case v: ValDef =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      v.tpt.tpe.typeSymbol.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s&quot;$name: $tpe&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Expr(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  s&quot;$name(${caseFields.mkString(&quot;,&quot;)})&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>And it gives this output:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;NonEmpty(e: T,tail: Option)&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Looks almost done. The only thing missing are the type parameters of Option. As I mentioned before, TypeRepr has many specific node types. So let‚Äôs take a look at some of them:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">+- TypeRepr -+- NamedType -+- TermRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |              +- TypeRef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            +- AppliedType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            +- AndOrType -+- AndType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |             +- OrType</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>There are more of them, so in a real-life scenario, we would have to handle all of them. But my example, my rules. Most of those types are structurally recursive, so will delegate our type extraction logic to a function. For every AST node type we can look for desired methods just like before. For NamedType there is a method name, for AppliedType we can just use unapply to get the tycon (Type Constructor) and args and so on. The result looks like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">def fullTypeName(tpe: TypeRepr): String = tpe match</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case t: NamedType =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       t.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case o: OrType =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       fullTypeName(o.left) + &quot; | &quot; + fullTypeName(o.right)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case o: AndType =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       fullTypeName(o.left) + &quot; &amp; &quot; + fullTypeName(o.right)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     case AppliedType(base, args) =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       fullTypeName(base) + args.map(fullTypeName).mkString(&quot;[&quot;, &quot;,&quot;, &quot;]&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>After using the function call in our main code. The result presents like this:</p><div class="codeBlockContainer_J+bg language-scala theme-code-block"><div class="codeBlockContent_csEI scala"><pre tabindex="0" class="prism-code language-scala codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">&quot;NonEmpty(e: T,tail: Option[NonEmpty[T]])&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Which is exactly what we wanted :D</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="takeaways">Takeaways<a class="hash-link" href="#takeaways" title="Direct link to heading">‚Äã</a></h2><p>The examples shown in this article are intentionally straightforward, just to show the basic process of working with TASTY reflect API. But the main ideas I wanted to show are:</p><ul><li>Look for node types in <a href="https://dotty.epfl.ch/api/scala/quoted/Quotes.html" target="_blank" rel="noopener noreferrer">Quotes</a></li><li>Look for implementation and methods in <a href="https://github.com/lampepfl/dotty/blob/main/compiler/src/scala/quoted/runtime/impl/QuotesImpl.scala" target="_blank" rel="noopener noreferrer">QuotesImpl</a></li><li>Macros in dotty are way easier to write than in Scala 2</li></ul><p>Code for this example is available <a href="https://github.com/KacperFKorban/tasty-macro-migration" target="_blank" rel="noopener noreferrer">here</a>.</p><p>Medium link: <a href="https://medium.com/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c" target="_blank" rel="noopener noreferrer">https://medium.com/virtuslab/tasty-way-of-re-writing-macros-in-scala-3-3ce704a2c37c</a></p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_xD8n"><div class="col"><b>Tags:</b><ul class="tags_NBRY padding--none margin-left--sm"><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala">scala</a></li><li class="tag_F03v"><a class="tag_WK-t tagRegular_LXbV" href="/blog/tags/scala-3">scala 3</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/KacperFKorban/kacperfkorban.github.io/blog/2021-04-29-TASTY-way-of-rewriting-macros-in-Scala-3.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/Achieving-Indisputable-Job-Security-Using-Novel-Scala-3-Features-A-Case-Study"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">¬´ <!-- -->Achieving Indisputable Job Security Using Novel Scala 3 Features: A Case Study</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/How-to-write-Hoogle-for-Kotlin-in-Scala-and-Scala-js"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">How to write Hoogle for Kotlin in Scala (and Scala.js)<!-- --> ¬ª</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#intro" class="table-of-contents__link toc-highlight">Intro</a></li><li><a href="#problem" class="table-of-contents__link toc-highlight">Problem</a></li><li><a href="#base" class="table-of-contents__link toc-highlight">Base</a></li><li><a href="#code-3" class="table-of-contents__link toc-highlight">Code &lt;3</a></li><li><a href="#takeaways" class="table-of-contents__link toc-highlight">Takeaways</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Content</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">Social media</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/KacperKorban" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/KacperFKorban" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2022 korban.dev, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.0de25d61.js"></script>
<script src="/assets/js/main.bb8a9f9b.js"></script>
</body>
</html>